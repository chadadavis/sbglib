#!/usr/bin/env perl

=head1 NAME

B<assemble> - Assemble components into complexes

=head1 SYNOPSIS



=head1 DESCRIPTION


=head1 OPTIONS

=head2 -h|elp Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head2 -f|ile Log file

Default: <network name>.log in current directory

=head2 -c|omplete

Only produce complex models that contain every component of the network

=head2 -s|ize

Minimum size of a complex model, in number of components, e.g.

 -s 4 (4 or more component proteins in complex models

 -s 75% (at least 75% of the components in the network are modelled)


=head1 SEE ALSO

L<SBG::CA::Assembler> , L<SBG::Network> , L<SBG::SearchI>

=cut

################################################################################

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Moose::Autobox;
use File::Basename;
use List::MoreUtils qw/each_arrayref/;
use POSIX;
use Carp;

use Hash::MoreUtils qw/slice_def/;

use File::Spec::Functions;
use File::NFSLock;
use Fcntl qw/LOCK_EX LOCK_NB/;

use SBG::Role::Storable;
use SBG::Network;
use SBG::Traversal;
use SBG::CA::Assembler;
use SBG::Complex;

use SBG::U::Log;
use Log::Any qw/$log/;
use Log::Any::Adapter;

use PBS::ARGV qw/qsub/;

################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'complete|c',
                        'overlap_thresh|o=f',
                        'minsize|s=s',
                        'h|help',
                        'l|loglevel=s',
                        'f|file=s', 
                        'd|debug',
    );                  
if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }
$SIG{__DIE__} = \&confes if $ops{'d'};

if ($ops{'l'}) {
    my $logfile = $ops{'f'} || basename($0) . '.log';
    SBG::U::Log::init($ops{'l'}, $logfile);
    Log::Any::Adapter->set('+SBG::U::Log');
}

# Recreate command line options;
my @dashops = map { '-' . $_ => $ops{$_} } keys %ops;
my @jobids = qsub("$0 @dashops");
print join("\n", @jobids), "\n", if @jobids;

foreach my $file (@ARGV) {

    my $basename = basename($file,'.stor');
    my $outdir = $basename;
    mkdir $outdir;
    my $donefile = catfile($outdir, $basename . '.done');

    # Setup new log file specific to given input file
    if ($ops{'l'}) {
        my $logfile = $ops{'f'} || catfile($outdir, $basename . '.log');
        SBG::U::Log::init($ops{'l'}, $logfile);
        Log::Any::Adapter->set('+SBG::U::Log');
    }
    $log->debug("$0 $file @dashops");

    # Already finished?
    if (-s $donefile) {
        my $d = `cat $donefile`;
        chomp $d;
        $log->info(sprintf "$basename : %5d already done\n", $d);
        next;
    }

    # Being computed by another process?
    unless (my $lock = File::NFSLock->new($donefile,LOCK_EX|LOCK_NB)) {
        $log->info("$basename : locked by: ", `cat ${donefile}*`);
        next;
    }

    # Load the Network object
    my $net = retrieve($file) or
        pod2usage(-exitval=>1, -verbose=>1, -message=>"$file is not an object");
    _print_net($basename, $net);

    $ops{minsize} = 3 unless defined $ops{minsize};
    # Only full-size (complete coverage) models?
    $ops{minsize} = '100%' if $ops{complete};
    $ops{minsize} = ceil(_frac_of($ops{minsize}, $net->nodes));

    # Traverse the network
    _one_net($net, $basename, \%ops);
    print "\n";

    my $root = catfile($outdir, $basename);
    my @done = <${root}*.stor>;
    my $done = scalar(@done);
    `echo $done > $donefile`;

}

exit;


################################################################################


# Convert percentage to literal amount
# Dont' forget to ceil() or int() the result, if you want a whole number
sub _frac_of {
    my ($frac, $of) = @_;
    $of ||= 100;
    my $abs = $frac;
    if ($frac =~ /^([.0-9])+\%$/) {
        $abs = $of * $1 / 100.0;
    }
    return $abs;
}


################################################################################
# 
sub _print_net {
    my ($basename, $net, $i, $n) = @_;
    $i ||= 1;
    $n ||= 1;
    my $str = sprintf
        "%-20s %4d nodes, %4d edges, %4d interactions \n",
        $basename,
        scalar($net->vertices), scalar($net->edges), 
        scalar($net->interactions);
    $log->info($str);
}


################################################################################
# Assemble network
sub _one_net {
    my ($net,$name, $ops) = @_;

    # Traversal algorithm, on the network
    # -test is the function to call when trying to place an interaction
    # -partial is the function to call when one complex solution is complete
    my %tops = slice_def($ops, 'minsize');
    my $t = new SBG::Traversal(graph=>$net, 
                               assembler=>
                               SBG::CA::Assembler->new(dir=>$name),
                               %tops,
        );
    # Each result is a complex, this is a placeholder for the aglorithm's state
    my %cops = slice_def($ops, 'overlap_thresh');
    my $state = new SBG::Complex(id=>$name,%cops);

    # Go!
    $t->traverse($state);

}




