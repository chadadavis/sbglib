#!/usr/bin/env perl

=head1 NAME

B<assemble> - Assemble components into complexes

=head1 SYNOPSIS



=head1 DESCRIPTION


=head1 OPTIONS

=head2 -h|elp Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head2 -f|ile Log file

Default: <network name>.log in current directory

=head2 -c|omplete

Only produce complex models that contain every component of the network

=head2 -s|ize

Minimum size of a complex model, in number of components, e.g.

 -s 4 (4 or more component proteins in complex models

 -s 75% (at least 75% of the components in the network are modelled)


=head1 SEE ALSO

L<SBG::CA::Assembler> , L<SBG::Network> , L<SBG::SearchI>

=cut

################################################################################

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Moose::Autobox;
use File::Basename;
use List::MoreUtils qw/each_arrayref/;
use POSIX;
use Carp;

use File::NFSLock;
use Fcntl qw/LOCK_EX LOCK_NB/;

use SBG::Role::Storable;
use SBG::Network;
use SBG::Traversal;
use SBG::CA::Assembler;
use SBG::Complex;

use SBG::U::Log;


################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
                        'c|complete',
                        's|size=s',
                        'l|log=s',
                        'f|file=s', 
                        'd|debug',
    );                  
if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }
$SIG{__DIE__} = \&confes if $ops{'d'};


my @files = @ARGV;

foreach my $file (@files) {

    my $basename = basename($file,'.stor');
    my $donefile = "${basename}.done";
    $ops{'f'} ||= "net2model-${basename}.log";
    SBG::U::Log::init($ops{'l'}, $ops{'f'}) if $ops{'l'};
    
    # Already finished?
    if (-s $donefile) {
        my $d = `cat ${basename}.done`;
        chomp $d;
        printf "$basename : %5d already done\n", $d;
        next;
    }

    # Being computed by another process?
    unless (my $lock = File::NFSLock->new($donefile,LOCK_EX|LOCK_NB)) {
        print "$basename : locked\n"; # By?
        next;
    }

    # Load the Network object
    my $net = retrieve($file) or
        pod2usage(-exitval=>1, -verbose=>1, -message=>"$file is not an object");
    _print_net($basename, $net);
    my $minsize = _minsize($net, %ops);

    # Traverse the network
    _one_net($net, $basename, $minsize);
    print "\n";

    my @done = <${basename}*.stor>;
    my $done = scalar(@done);
    `echo $done > ${basename}.done`;

}

exit;


################################################################################
# Parse the -s command line option (minsize of complex predictions)
sub _minsize {
    my ($net, %ops) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    my $minsize = $ops{'s'} || 3;
    # Only full-size (complete coverage) models?
    $minsize = '100%' if $ops{'c'};
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($net->nodes() * $1 / 100.0);
    }
    return $minsize;
}


################################################################################
# 
sub _print_net {
    my ($basename, $net, $i, $n) = @_;
    $i ||= 1;
    $n ||= 1;
    printf 
        "%-20s %4d nodes, %4d edges, %4d interactions \n",
        $basename,
        scalar($net->vertices), scalar($net->edges), 
        scalar($net->interactions);
}


################################################################################
# Assemble network
sub _one_net {
    my ($net,$name, $minsize) = @_;

    # Traversal algorithm, on the network
    # -test is the function to call when trying to place an interaction
    # -partial is the function to call when one complex solution is complete
    my $t = new SBG::Traversal(graph=>$net, 
                               assembler=>SBG::CA::Assembler->new(),
                               minsize=>$minsize,
        );
    # Each result is a complex, this is a placeholder for the aglorithm's state
    my $state = new SBG::Complex(id=>$name,overlap_thresh=>0.75);

    # Go!
    $t->traverse($state);

}




