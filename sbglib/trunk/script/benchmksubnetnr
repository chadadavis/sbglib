#!/usr/bin/env perl

use SBG::Role::Storable;
use Moose::Autobox;
use File::Basename;

use SBG::Model;
use SBG::Complex;
use SBG::GeometricHash;
use SBG::DB::scop qw/scopdomain/;
use SBG::Run::cofm qw/cofm/;

use Carp;
$SIG{__DIE__} = \&confess;


my $files = [sort @ARGV];
my $bases = $files->map(sub{basename($_, '.stor')});
my $subnets = $files->map(sub{retrieve($_)});
exit unless $subnets->length;
my $complexes = $subnets->map(sub{_net2complex($_)});

for (my $i = 0; $i < @$files; $i++) {
    print STDERR $complexes->[$i], "\n";
    unless (defined _unique($complexes->[$i])) {
        print STDERR "Deleting duplicate subnet ", $files->[$i], "\n";
        unlink $files->[$i];
    }
}

exit;

# Specific to benchmark nets, where we know the structure of what we're trying
# to build
sub _net2complex {
    my ($net,) = @_;
    my @nodes = $net->nodes;
    my $complex = new SBG::Complex;
    foreach my $node (@nodes) {
        my $model = new SBG::Model(query=>$node, subject=>scopdomain($node));
        $complex->set($node, $model);
    }
    return $complex;
}

# Geometrically hash complexes of disconnected subnets, to determine uniqueness
sub _unique {
    my ($complex) = @_;

    our $gh;
    $gh ||= new SBG::GeometricHash(binsize=>1.5);

    my $id = $complex->id;
    # Keep objects in defined order
    my $keys = $complex->keys;
    my $models = $keys->map(sub{$complex->get($_)});
    my $doms = $models->map(sub{$_->subject});
    my $spheres = $doms->map(sub{cofm($_)});
    my $centroids = $spheres->map(sub{$_->centroid});
    
    my $class = $gh->exact($centroids); # No labels (find all)
    if (defined $class) {
        # Dup
        return;
    } else {
        # Unique
        $class = $gh->put(undef, $centroids, $keys);
        return $complex;
    }
}
 
