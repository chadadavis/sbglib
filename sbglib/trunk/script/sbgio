#!/usr/bin/env perl

=head1 NAME

B<sbgobj> - Interface to serialized objects 

=head1 SYNOPSIS

sbgobj myfile.stor <object-method> <parameters> ...

=head1 DESCRIPTION

Calls the given method on the object stored in myfile.stor

If no method is given, the object is printed.


Uses bash autocomplete:
 
 complete -o default -C 'sbgobj -options' sbgobj


=head1 OPTIONS

=head2 -k Keep temporary files

For debugging

=head2 -l Log level

One of:

 TRACE DEBUG INFO WARN ERROR FATAL

=head2 -h Help

=head1 SEE ALSO

L<SBG::Role::Storable>

=cut

################################################################################

# CPAN
use Getopt::Long qw/:config/; # qw/:config auto_help/;
use Pod::Usage;
use File::Temp;
use Scalar::Util qw/blessed/;
use Moose::Autobox;

use SBG::Role::Storable qw/module_for retrieve can_do/;
use SBG::U::Log;
use SBG::Seq;

use Data::Dump qw/dump/;

################################################################################

my @avail_ops = (
    'l|log=s',
    'k|keep',
    'h|help',
    );
# First check for shell command line completion
_complete_options(@avail_ops);

# Otherwise process outstanding standard options
my %ops;
my $result = GetOptions(\%ops, @avail_ops);

SBG::U::Log::init($ops{'l'}) if $ops{'l'};
$File::Temp::KEEP_ALL = 1 if $ops{'k'};

# Get arguments
my ($file,$method,@args) = @ARGV;
pod2usage(-exitval=>2,-verbose=>2) unless defined $file;
my $obj = retrieve($file);
pod2usage(-exitval=>2,-verbose=>2) unless defined $obj;
if ($ops{'h'}) { 
    my $mstr = "$file can do:\n\t" . join("\n\t", _methods($obj));
    pod2usage(-msg=>$mstr,-exitval=>0,-verbose=>1);
}

@args = _load_args(@args);
my @res = $method ? $obj->$method(@args) : ("$obj");
print "@res";
print "\n" unless $res[$#res] =~ /\n$/;


################################################################################

# If any param is readable file, convert to object
sub _load_args {
    map { -r $_ ? retrieve($_) : $_ } @_;
}

sub _methods {
    my ($obj) = @_;
    return unless defined($obj);
    my @all_methods;
    my $methods = $obj->can_do;
    # TODO use this instead, but will contain different object
#     my @methods = $obj->meta->get_all_methods;

    my $keys = $methods->keys->sort;
    foreach my $class (@$keys) {
        my $names = $methods->{$class}->sort;
        push(@all_methods, "${class}::${_}") for @$names;
    }
    return @all_methods;
}


sub _complete_options {
    my (@ops) = @_;
    our @ARGV;
    Getopt::Long::Configure('pass_through');
    my $options;
    GetOptions('options' => \$options);

    unless ($options) {
        # Reset
        Getopt::Long::Configure('pass_through');
        return;
    }

    my (undef, $current, $preceding) = @ARGV;
    if ($current =~ /^-/) {
        my @opnames = map { s/.\|//; s/=/ /; '-' . $_ } @ops;
        my @matches = grep { /^$current/ } @opnames;
        print join("\n",@matches);
    } else {
        my ($method, $file) = ($current, $preceding);
        exit unless defined($file);
        my $obj = retrieve($file);
        exit unless defined($obj);
        my @methods = _methods($obj);
#         warn "method:$method:file:$file:methods:@methods:\n";
#         warn "ref:", ref $obj;
        my @matches = grep { /$method/ } @methods;
        print join("\n", @matches);
    }
    exit;

} # _complete_options




__END__


Make this a CGI as well
Look for models in a given dir

    # Save files;
    my $domio;
    $domio = new SBG::DomainIO::stamp(tempfile=>1);
    $domio->write(@{$model->domains});
    $obs{'modeldom'} = $domio->file;
    $domio = new SBG::DomainIO::stamp(tempfile=>1);
    $domio->write(@{$model->domains}, @{$target->domains});
    $obs{'superdom'} = $domio->file;
    my $pdbio = new SBG::DomainIO::pdb(tempfile=>1);
    $domio = new SBG::DomainIO::
                  
    # Save STAMP DOM file of $model, before superpositioning it
#     my $io = new SBG::DomainIO::stamp(tempfile=>1);
#     $io->write(@{$model->domains});
#     print $io->file;
