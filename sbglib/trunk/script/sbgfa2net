#!/usr/bin/env perl

=head1 NAME

B<sbgfa2net> - 

=head1 SYNOPSIS

sbgfa2net <fasta-sequences.fa>

=head1 DESCRIPTION


=head1 OPTIONS

=head2 -m|ethod B<standaloneblast> or B<remoteblast>

=head2 -h|elp Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head2 -f|ile Log file

Default: <network name>.log in current directory


=head1 SEE ALSO

L<SBG::Network> , L<SBG::SearchI>

=cut

################################################################################


use strict;
use warnings;

use File::Basename;
use Moose::Autobox;
use Bio::SeqIO;

use SBG::U::Run qw/frac_of getoptions start_lock end_lock start_log/;

use SBG::Network;
use SBG::Search::TransDB;


use PBS::ARGV qw/qsub/;

my %ops = getoptions 
    qw/maxid|x=i minid|n=i output|o=s cache|c=i top|t=i method|m=s/;


# Recreate command line options; (seems to work even ith long option names)
my @dashops = map { '-' . $_ => $ops{$_} } keys %ops;
my @jobids = qsub("$0 @dashops");
print join("\n", @jobids), "\n", if @jobids;


foreach my $file (@ARGV) {

    # Setup new log file specific to given input file
    my $basename = basename($file,'.fa');
    my $lock = start_lock($basename) or next;
    start_log($basename, %ops);

    # Add each sequence as a node to new network
    my $net = SBG::Network->new;
    my $seqio = Bio::SeqIO->new(-file=>$file);
    while (my $seq = $seqio->next_seq) {
        $net->add_seq($seq);
    }

    # Searcher tries to find interaction templates (edges) to connect seq nodes
    my $blast = SBG::Run::PairedBlast->new;
    $blast->method($ops{method}) if $ops{method};
    my $searcher = SBG::Search::TransDB->new(blast=>$blast);
    my $buildops = {%ops}->hslice([qw/maxid minid cache top/]);
    # Create interaction templates on the edges of the network
    $net = $net->build($searcher,%$buildops);
    
    my $base = $ops{output} || $basename;
    my @subnets = $net->partition(minsize=>3);
    _write_partitions($base, @subnets);

    end_lock($lock, scalar $net->interactions);

}


exit;

################################################################################


sub _write_partitions {
    my ($label, @subnets) = @_;
    $label ||= '';
    my @files;
    for (my $i = 0; $i < @subnets; $i++) {
        # 1-based counting
        my $filename = sprintf "%s-net-%04d.stor", $label, $i+1;
        if (-f $filename) {
            print STDERR "$filename already exists. Skipping.\n";
        } else {
            $subnets[$i]->store($filename);
        }
        push @files, $filename;
    }
    return @files;
}
