#!/usr/bin/env perl

=head1 NAME

B<bencheval> - Evaluate a complex against models of it

=head1 SYNOPSIS

 bencheval true-complex-file.stor model1.stor model2.stor ...

=head1 DESCRIPTION



=head1 OPTIONS

=head2 -l|log=s     log level

=head2 -f|field=s   field name to sort on

=head2 -b|best=s    Best N (or N%) (per size, if -u)

=head2 -s|size=s    minimum N (or N%) components per model

=head2 -c|complete  Only full-coverage models

=head2 -r|reverse   reverse sort

=head2 -u|unique    unique by size (diff. sizes separately)

=head2 -h Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head1 SEE ALSO



=cut

################################################################################


use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use File::Basename;
use POSIX; # qw/ceil/;
use Carp;
use CGI qw/:standard *table/;
use Data::Dump qw/dump/;
use Moose::Autobox;
use autobox ARRAY => 'SBG::U::List';
use SBG::U::List qw/mean avg median sum min max flatten/;

# use SBG::Eval;
use SBG::Role::Storable;
use SBG::U::HTML qw/formattd rcsb/;

use SBG::Run::pdbc qw/pdbc/;
use SBG::Run::rasmol qw/rasmol pdb2img/;
use SBG::DomainIO::stamp;
use SBG::DomainIO::pdb;
use SBG::InteractionIO::html;
use SBG::SuperpositionIO::html;

################################################################################

my %ops;
my $result = GetOptions(\%ops,
                        'help|h',
                        'log|l=s',   # log level
                        'debug|d',   # print stack trace when die
                        'output|o',  # html or csv
                        'size|s=s',  # minimum N (or N%) components per model
                        'complete|c',# Only full-coverage models
                        'field|f=s', # field name to sort on
                        'thresh|t=f',# min threshold val for field
                        'best|b=s',  # Best N (or N%) (per size, if -u)
                        'reverse|r', # reverse sort
                        'minseqid|n=f',   # minimum seqid to allow
                        'maxseqid|x=f',   # maximum seqid to allow
    );                  


if ($ops{'help'}) { pod2usage(-exitval=>1, -verbose=>2); }
SBG::U::Log::init($ops{'log'}) if $ops{'log'};
$SIG{__DIE__} = \&confess if $ops{'debug'};
$ops{'size'} = '100%' if $ops{'complete'};

# Sort descending on Sc by default
unless (defined $ops{'field'}) {
    $ops{'field'} ||= 'medsc';
    $ops{'reverse'} = 1;
    $ops{'thresh'} = 5;
}

mkdir($_) for qw/pdb dom html/;

my @idxkeys = 
    qw/target nmodels ngood model msize rmsd medsc nres seqids superpos/;
my @allkeys = qw/target model msize rmsd medsc seqids superpos/;


# First file is the target/benchmark/true complex
my $targetfile = shift or pod2usage(-exitval=>1);
# Eval all other files as models, against target
my ($best, $all) = evaltarget(\%ops, $targetfile, @ARGV);

my $tbase = basename($targetfile, '.stor');
my ($pdb, $tid) = split '-', $tbase;
$best->{'target'} = rcsb($pdb) . '-' . a({-href=>"${tbase}.html"},$tid);

my $idxrow = td([map { $best->{$_} } @idxkeys ]);
my ($idxfh,$idxlock) = openidxhtml(@idxkeys);
print $idxfh Tr($idxrow);
close $idxfh;
unlink $idxlock;

my @allrows = map { my $m=$_; td([map { $m->{$_} } @allkeys ]) } @$all;
my $allrow = Tr(\@allrows);
my ($allfh, $alllock) = openallhtml(@allkeys);
print $allfh Tr($allrow);
close $allfh;
unlink $alllock;

exit;


################################################################################

sub openidxhtml {
    my (@keys) = @_;
    my $file = "html/index.html";
    my $lock = wlock($file, 60);
    if (-s $file) {
        open my $fh, ">>$file";
        return wantarray ? ($fh, $lock) : $fh;
    } else {
        open my $fh, ">$file";
        print $fh start_html("Top models");
        print $fh h2("Top models, by target"), "\n";
        print $fh start_table({-border=>'1'});
        print $fh Tr(th([ @keys ]));
        return wantarray ? ($fh, $lock) : $fh;
    }
}


sub openallhtml {
    my (@keys) = @_;
    my $file = "html/all.html";
    my $lock = wlock($file, 60);
    if (-s $file) {
        open my $fh, ">>$file";
        return wantarray ? ($fh, $lock) : $fh;
    } else {
        open my $fh, ">$file";
        print $fh start_html("All models");
        print $fh h2("All models"), "\n";
        print $fh start_table({-border=>'1'});
        print $fh Tr(th([ @keys ]));
        return wantarray ? ($fh, $lock) : $fh;
    }
}


sub evaltarget {
    my $ops = {};
    $ops = shift(@_) if ref($_[0]) eq 'HASH';
    my ($targetfile, @modelfiles) = @_;
    my $target = retrieve($targetfile);
    unless (defined $target) {
        warn "No target in: $targetfile\n";
        return;
    }

    # How much of the target complex do the models need to cover
    my $tsize = $target->count;
    # Convert possible size% to integer 
    $ops->{'size'} = _minsize($tsize, $ops->{'size'});

    my $tbase = basename($targetfile, '.stor');
    # Output for all models on this target
    my $file = "html/${tbase}.html";
    open my $fh, ">$file";

    print $fh start_html($tbase);
    print $fh h2(rcsb("Target $tbase")), "\n";
    print $fh start_table({-border=>'1'});
#     my @keys = qw/model msize nres rmsd medsc seqids superpos/;
    my @keys = qw/model msize rmsd medsc seqids superpos/;
    print $fh Tr(th([ @keys ]));

    my $evmodels = [];

    open my $rmsdfh, ">>rmsdcorr.csv";
    print $rmsdfh "#target\tmodel\trmsd\tavgsc\tmedsc\tsumsc\tminsc\tmaxsc\n";

    foreach my $modelfile (@modelfiles) { 
        my %ev = evalmodel($ops, $target, $modelfile) or next;
        my $row = td([map { $ev{$_} } @keys ]);
        print $fh Tr($row);

        my ($pdb, $tid) = split '-', $tbase;
        $ev{'target'} = rcsb($pdb) . '-' . a({-href=>"${tbase}.html"},$tid);
        $evmodels->push({%ev});

        my @fields = map { $ev{$_} } qw/rmsd avgsc medsc sumsc minsc maxsc/;
        my $lock = wlock('rmsdcorr.csv', 1);
        if ($lock) {
        print $rmsdfh 
            join("\t",$tbase,basename($modelfile,'.stor'), @fields), "\n";
        }
        unlink $lock;

    } # foreach $modelfile
    close $rmsdfh;

    print $fh end_table();
    close $fh;

    # TODO Sort ... TODO command line option
    # TODO also honor reverse sort option
    my $field = $ops->{'field'};
    my @sorted = sort { $a->{$field} <=> $b->{$field} } @$evmodels;
    @sorted = reverse(@sorted) if $ops->{'reverse'};
    my $best = $sorted[0];

    # Addtl stats (over all models)

    $best->{'nmodels'} = scalar(@sorted);
    my $subgood = sub{!($_->{$field}<$ops->{'thresh'})&&$_->{'cover'}>=50};
    my @good = grep { $subgood->($_) } @sorted;
    $best->{'ngood'} = scalar(@good);

    return $best, $evmodels;

} # evaltarget


################################################################################
sub evalmodel {
    my $ops = {};
    $ops = shift(@_) if ref($_[0]) eq 'HASH';
    my ($target, $modelfile) = @_;

    my $model = retrieve $modelfile;

    my $mbase = basename($modelfile, '.stor');
    my $file = "html/${mbase}.html";
    open my $fh, ">$file";
    print $fh start_html($mbase);
    print $fh h2("Model $mbase"), "\n";
    print $fh start_table({-border=>'1'});
    my @keys = qw/target superpos dom rmsd cover msize tsize glob nres medsc avgsc seqids/;
    print $fh Tr(th([ @keys ]));

    my %ev = (base=>$mbase);
    my ($tpdb, $tid, undef, $mid) = split '-', $mbase;
    $ev{'target'} = rcsb($tpdb . '-' . $tid);

    return unless defined($model);
    return if $model->count < $ops->{'size'};

    modelstats(\%ev, $target, $model);
    modellinks(\%ev);
    modeloutputs(\%ev, $target, $model);

    my @seqids = @{$ev{'seqids'}};

    # skip if seqid thresh not met
    return if defined($ops->{'minseqid'}) && ! $seqids[0] >= $ops->{'minseqid'};
    return if defined($ops->{'maxseqid'}) && ! $seqids[1] <= $ops->{'maxseqid'};
    $ev{'seqids'} = join('-', @seqids);

    my $row = td([map { $ev{$_} } @keys]);
    print $fh Tr($row);
    print $fh end_table();

    my $iactionio = new SBG::InteractionIO::html(fh=>$fh);
    $iactionio->write($model->interactions->values);
    my $supio = new SBG::SuperpositionIO::html(fh=>$fh);
    $supio->write($model->superpositions->values);

    close $fh;
    return %ev;
}


sub modellinks {
    my ($ev) = @_;
    my $base = $ev->{base};
    my ($tpdb, $tid, undef, $mid) = split '-', $base;
    $ev->{'model'} = a({-href=>"${base}.html"}, $mid);
    $ev->{'dom'} = a({-href=>"../dom/${base}.dom"}, 'dom');
    $ev->{'superpos'} = a({-href=>"../pdb/${base}.pdb"}, 'superpos');
}


################################################################################
sub modelstats {
    my ($ev, $target, $model) = @_;

#     my ($rmsd, $trans) = modelrmsd($target, $model);
    my ($rmsd, $trans) = modelrmsd($model, $target);

    $ev->{'rmsd'} = sprintf "%.2f", $rmsd;
    $ev->{'trans'} = $trans;
    $ev->{'cover'} = sprintf "%6.2f", 100.0 * $model->count / $target->count;
    $ev->{'msize'} = $model->count;
    $ev->{'tsize'} = $target->count;
    $ev->{'glob'} = sprintf "%6.2f", $model->globularity;
    $ev->{'nres'} = $model->domains->map(sub {$_->length})->sum;

    my $scs = $model->superpositions->values->map(sub{$_->scores->at('Sc')});

    $ev->{'medsc'} = sprintf "%.2f", $scs->median;
    $ev->{'avgsc'} = sprintf "%.2f", $scs->avg;
    $ev->{'sumsc'} = sprintf "%.2f", $scs->sum;
    $ev->{'minsc'} = sprintf "%.2f", $scs->min;
    $ev->{'maxsc'} = sprintf "%.2f", $scs->max;

    my $iactions = $model->interactions->values;
    my $models = $iactions->map(sub{ flatten $_->models->values });
    my $seqids = $models->map(sub{$_->scores->at('seqid')});
    $seqids = $seqids->map(sub{ isalpha($_) ? 0 : sprintf("%d",$_) });
    my @seqids = sort { $a <=> $b } @$seqids;
    $ev->{'seqids'} = [ shift(@seqids), pop(@seqids) ];

# TODO
#     * avg clash %

}


################################################################################

sub modelrmsd {
    my ($model, $target) = @_;

# TODO which superposition
#     my $transmat = $model->superposition_frame_cofm3($target);
    my ($transmat, $rmsd) = $model->superposition_points($target);

    # Now crosshairs have the proper orientation
#     $model->transform($transmat);

    # TODO BUG this doesn't give the same answer as the above $rmsd
#     my $rmsd = $model->rmsd($target);
    return wantarray ? ($rmsd, $transmat) : $rmsd;
}


################################################################################
sub _sort {
    my ($observations, $field, $reverse) = @_;
    return $observations unless $field;
    $observations = [ sort { $a->{$field} <=> $b->{$field} } @$observations ];
    $observations = [ reverse @$observations ] if $reverse;
    return $observations;
}


################################################################################
# Only top N, or top N% ?
# Assuming $observations already sorted
sub _top {
    my ($observations, $best) = @_;
    return $observations unless $best;
    if ($best =~ /(\d+)\%$/) {
        $best = ceil(@$observations * $1 / 100.0);
    }
    $observations = @{$observations}[0..$best-1];
    return $observations;
}



################################################################################
# target tsize model msize cover rmsd olap irmsd pval zscore seqid eval sc glob
sub _print_html {
    my ($table, $tbase) = @_;
    our @fields;
    our $boundary = 4;
    our @ranges;

    print header if defined($ENV{GATEWAY_INTERFACE});
    print start_html($tbase);
    print start_table({-border=>'1'}, $tbase);

    my @htmlfields = (@fields, qw/pdb dom ppm/);
    print th([@htmlfields]);

    foreach my $row (@$table) {
        my $mbase = join('-', $row->{target}, 'model', $row->{model});
        
        $row->{rmsd} = sprintf("%.2f", $row->{rmsd});
        $row->{irmsd} = sprintf("%.2f", $row->{irmsd});
        $row->{sc} = sprintf("%.2f", $row->{sc});
        $row->{glob} = sprintf("%6.2f", $row->{glob}); 
        $row->{seqid} = sprintf("%6.2f", $row->{seqid}); 
        $row->{cover} = sprintf("%6.2f", $row->{cover}); 

        # Maintain order
        my @ordrow = map { $row->{$_} } @fields;

        my @tdrow = map { td($_) } @ordrow[0..$boundary-1];


        for (my $i = $boundary; $i < @ordrow; $i++) {
            my $color = mapcolor($ordrow[$i], @{$ranges[$i]});
            push @tdrow, td({-bgcolor=>$color}, $ordrow[$i]);
        }

       push 
           @tdrow, 
            td(a({-href=>"pdb/$mbase.pdb"}, 'pdb')), 
            td(a({-href=>"dom/$mbase.dom"}, 'dom')),
            td(({-href=>"ppm/$mbase.ppm"}, 'ppm')),
            ;
        print Tr({-align=>'right'}, "@tdrow"), "\n";
    }

    print end_html;
} # _print_html


sub _load_eval {
    my ($evalfile, $modelfile, $minsize) = @_;
    return unless -s $modelfile;
    my $ev;
    if (-s $evalfile) {
        $ev = retrieve $evalfile;
        return $ev;
    }

    # Being computed by another process?
    my $lock = wlock($evalfile, 1);
    unless ($lock) {
        print STDERR "$evalfile : locked\n";
        return;
    }

    $ev = _eval_one($modelfile, $minsize);
    if (! -s $evalfile) {
        $ev->store($evalfile);
#         print "evalfile written\n";
    }
    unlink $lock;
    return $ev;
} # _load_eval


sub _eval_one {
    my ($modelfile, $minsize) = @_;
    our $tbase;
    our $tsize;
    our $target;

    my $model = retrieve $modelfile;
    return unless defined($model);
    my $msize = $model->count;
    next if $msize < $minsize;
    my $mbase = basename($modelfile, '.stor');
    my ($mid) = $mbase =~ /-(\d+)$/;

    my %obs = (
        target=>$tbase, tsize=>$tsize, model=>$mid, msize=>$msize,
        glob=>$model->globularity,
        cover=>1.0 * $msize / $tsize,
        _domain_scores($model),       # eval seqid
        _interaction_scores($model),  # irmsd zscore pval
        _superposition_scores($model),# sc
        );


    # Superpose model onto target
    # TODO BUG cannot transform model here, as it already has a transform
    # And it's not multiplied correctly.
    # So we have to transform target onto model

    my ($avgmat, $urmsd, $usc ) = $target->superposition_frame_cofm3($model);

    $target->transform($avgmat);

    $obs{avgmat} = $avgmat;

    # 'sc' field is already reserved for mean linker Sc score
#     $obs{'sc'} = $usc;

    # RMSD of centroids after superposition 
#     $obs{'rmsd'} = $model->rmsd($target);
    # Mean RMSD of componentwise superposition
#     $obs{rmsd} = $urmsd;
    # RMSD of crosshairs
    $obs{rmsd} = $target->rmsd($model);

    # Now that they're in one coordinate frame, get component-wise overlaps
    # TODO divide by 0 erorr
#     $obs{olap} = $model->overlap($target);
    $obs{olap} = 0;

    foreach (qw/cover glob olap/) {
        $obs{$_} = sprintf("%6.2f", 100.0 * $obs{$_}); 
    }
    # NB seqid/); # seqid already a %

    # Put the target back where it came from
    # TODO wouldnt be necessary if transforming the model would work ...
    $target->transform($avgmat->inv);


#     return new SBG::Eval(%obs);


} # _eval_one


# STill want to save: mbase tbase targetfile modelfile 
sub _outputs {
    my ($evalfile, $modelfile, $target) = @_;

    my $mbase = basename($modelfile, '.stor');
    my $pdbfile = "pdb/${mbase}.pdb";
    my $domfile = "dom/${mbase}.dom";
    my $ppmfile = "ppm/${mbase}.ppm";
    my @files = ($pdbfile, $domfile, $ppmfile);
    my @locks = map { "$_.lock" } @files;
    my $alldone = 1;
    foreach (@files) {
        unless (-e $_ || -e "$_.lock") { $alldone = 0 }
    }
    return if $alldone;

    my $model = retrieve $modelfile;
    my $ev = retrieve $evalfile;
    my $avgmat = $ev->avgmat;

    # transform ...
    $target->transform($avgmat);

    _domfile($domfile, $model, $target);
    _pdbfile($pdbfile, $model, $target);
#     _ppmfile($mbase, $model, $target);

# TODO needed here?
    # Put the target back where it came from
    # TODO wouldnt be necessary if transforming the model would work ...
    $target->transform($avgmat->inv);

}


sub modeloutputs {
    my ($ev, $target, $model) = @_;

    my $mbase = $ev->{base};
    my $pdbfile = "pdb/${mbase}.pdb";
    my $domfile = "dom/${mbase}.dom";
    my $ppmfile = "ppm/${mbase}.ppm";
    my @files = ($pdbfile, $domfile, $ppmfile);
    my @locks = map { "$_.lock" } @files;
    my $alldone = 1;
    foreach (@files) {
        unless (-e $_ || -e "$_.lock") { $alldone = 0 }
    }
    return if $alldone;

    my $transmat = $ev->{trans};

    # transform ...
    $model->transform($transmat);

    _domfile($domfile, $model, $target);
    _pdbfile($pdbfile, $model, $target);
#     _ppmfile($mbase, $model, $target);

# TODO needed here?
    # Put the target back where it came from
    # TODO wouldnt be necessary if transforming the model would work ...
#     $target->transform($avgmat->inv);

} # modeloutput


sub _domfile {
    my ($domfile, $model, $target) = @_;

    if (-s $domfile) {
#         print STDERR "$domfile already done\n";
        return;
    }
    my $lock = wlock($domfile, 1);
    unless ($lock) {
        print STDERR "$domfile : locked\n";
        return;
    }

    # Rewrite model file in target's frame of reference, for convenience later
    my $domio = new SBG::DomainIO::stamp(file=>">$domfile");
    $domio->write(@{$target->domains}, @{$model->domains});
#     print "$domfile written\n";
    unlink $lock;
}


sub _pdbfile {
    my ($pdbfile, $model, $target) = @_;

    if (-s $pdbfile) {
#         print STDERR "$pdbfile already done\n";
        return;
    }
    my $lock = wlock($pdbfile, 1);
    unless ($lock) {
        print STDERR "$pdbfile : locked\n";
        return;
    }

    my $targetasdom = $target->merge;
    my $modelasdom = $model->merge;

    # Rewrite model file in target's frame of reference, for convenience later
    my $pdbio = new SBG::DomainIO::pdb(file=>">$pdbfile");
    $pdbio->write($targetasdom, $modelasdom);
#     print "$pdbfile written\n";
    unlink $lock;
}


sub _ppmfile {
    my ($mbase, $model, $target) = @_;

    my $pdbfile = "pdb/${mbase}.pdb";
    my $ppmfile = "ppm/${mbase}.ppm";

    if (-s $ppmfile) {
#         print STDERR "$ppmfile already done\n";
        return;
    }
    my $lock = wlock($ppmfile, 1);
    unless ($lock) {
        print STDERR "$pdbfile : locked\n";
        return;
    }

    pdb2img(pdb=>$pdbfile, img=>$ppmfile);
#     print "$ppmfile written\n";
    unlink $lock;
}


################################################################################
sub _minsize {
    my ($totalsize, $minsize, $complete) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    $minsize = 3 unless defined $minsize;

    # Only full-size (complete coverage) models?
    $minsize = '100%' if $complete;
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($totalsize * $1 / 100.0);
    }
    return $minsize;
}


################################################################################
sub _domain_scores {
    my ($complex) = @_;
    my $models = $complex->models->values;
    
    my $ev = [];
    my $seqid = [];

    foreach my $model (@$models) {

        # fam superf and fold relations marked by 'REL' in eval
        my $e = $model->scores->at('eval');
        my $s = $model->scores->at('seqid');

        if (defined($e) && $e !~ /REL/) {
            $ev->push($e);
            $seqid->push($s);
        }
    }
    my %obs;
    $obs{'eval'} = $ev->sum || "NaN";
    $obs{'seqid'} = $seqid->mean || "NaN";
    return %obs;
} # _domain_scores


################################################################################
sub _interaction_scores {
    my ($complex) = @_;

    my $irmsd = [];
    my $zscore = [];
    my $pval = [];
    
    my $interactions = $complex->interactions->values;
    foreach my $interaction (@$interactions) {
        # Scores for interaction as a whole
        $irmsd->push($interaction->scores->at('irmsd'));
        $zscore->push($interaction->scores->at('zscore'));
        $pval->push($interaction->scores->at('pval'));

    }
    my %obs;
    $obs{irmsd} = $irmsd->mean || "NaN";
    $obs{zscore} = $zscore->mean || "NaN";
    $obs{pval} = $pval->sum || "NaN";
    return %obs;
} # _interaction_scores


################################################################################
sub _superposition_scores {
    my ($complex) = @_;
    
    # STAMP scores
    my $sc = [];
    
    my $superpositions = $complex->superpositions->values;
    foreach my $superposition (@$superpositions) {
        $sc->push($superposition->scores->at('Sc'));
    }
    my %obs;
    $obs{'sc'} = $sc->mean || "NaN";
    return %obs;
} # _superposition_scores



sub wlock {
    my $file = shift or return;
    my $attempts = shift || 5;
    my $lock = "${file}.lock";
    until (symlink("$ENV{HOSTNAME}-$$", $lock)){
        $attempts--;
        return unless $attempts > 0;
        sleep 1 + int rand(5);
        my $full = rel2abs($lock);
        print "Waiting for lock: $full ($attempts)\n";
    }
    return $lock;
} # wlock


sub mapcolor {
    my ($val, $min, $max, $colora, $colorb) = @_;
    $colora ||= 0x33;
    $colorb ||= 0xff;
    my $mapped = maprange($val, $min, $max, $colora, $colorb);
    my $hex = sprintf("%x", $mapped);
    my $hexstr = '#' . ($hex x 3);
    return $hexstr;
}

sub maprange {
    my ($val, $min1, $max1, $min2, $max2) = @_;
    return interpolate( norm($val, $min1, $max1), $min2, $max2);
}
sub interpolate {
    my ($norm, $min, $max) = @_;
    return $min + ($max - $min) * $norm;
}
sub norm {
    my ($val, $min, $max) = @_;
    return ($val - $min) / ($max - $min);
}


