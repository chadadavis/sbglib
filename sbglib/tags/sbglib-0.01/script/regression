#!/usr/bin/env perl

use strict;
use warnings;
use Statistics::Regression;
use Data::Dumper;
use List::MoreUtils;

# Column keys to the evaluation report
our @keys = qw/PDB Benchmark N Model N Iact Cover RMSD Olap iRMSD i2Z i2P i2E i2SID Sc RMS Al Fit Eq %I %S P(m)/;

# 1-based Positions of the above keys
my @positions = (1..@keys);
# Map keyname to 1-based column number
our %key2pos = List::MoreUtils::mesh @keys, @positions;

# Three measures of correctness (output vars)
# my $goal = 'RMSD';
my $goal = 'iRMSD';
# my $goal = 'Olap';

# Measures of model reliability (Input variables)
# Impossible, but interprets-pvalue inversely correlated (strongly) to RMSD
# i2E fucks up too, but we're can't have known that ahead of time
my @vars = qw/i2Z i2SID Sc RMS Al Fit Eq %I %S P(m)/;

# Regression requires a constant for the intercept. Will be adjusted
my $const = 1.0;

# Create regression object using the above variables
my $reg = Statistics::Regression->new("Vs. $goal (\$$key2pos{$goal})", ["const", @vars]);

while (<>) {
    my @fields = split;
    # Clean out 'nan' which Regression will not handle
#     @fields = map { /^nan$/ ? 0 : $_ } @fields;
    @fields = map { /^nan$/ ? 'NaN' : $_ } @fields;
    # Use the key names to make a hash out of the data
    my %datum = List::MoreUtils::mesh @keys, @fields;
    # Always add a constant to the formula
    $datum{'const'} = $const;

    # Hack interprets
    $datum{'i2P'} = 'NaN' if $datum{'i2P'} > .95;
#     $datum{'i2E'} = 'NaN' if $datum{'i2E'} < 1e-6;

#     printf 
#         "Adding $goal:%8.4f ~ %s\n", $datum{$goal},
#         join(' + ', map({sprintf("$_:%8.4f", $datum{$_})} @vars));

    # We add the whole hash, but only the named @vars are used in regression
    $reg->include($datum{$goal}, \%datum);
}

$reg->print;
# print Dumper $reg;

# Determine vars with high theta and low standard errors
my $theta_thresh = 1;
my $se_thresh = 5;
my @thetas = $reg->theta();
my @se = $reg->standarderrors();
my @names = @{$reg->{'xnames'}};
# Start with const (always present):
my @strings = sprintf('%8.4f',$thetas[0]);
for (my $k = 1; $k < $reg->k(); $k++) {
#     print STDERR "k:$k $names[$k]\n";
#     next unless abs($thetas[$k]) > $theta_thresh;
    next unless $se[$k] < $se_thresh; 
    # Gnuplot format with 1-based column names like ($5+$6)
    push @strings, 
    '$' . $key2pos{$names[$k]} . ' * ' . sprintf('%8.4f',$thetas[$k]);
}
print join(' + ', @strings), "\n";

# Print this in gnuplot with something like:
# plot 'eval-class.csv' using (3.1743+$12*4.4035+$16*2.5170+$22*-1.0028):($10)
# Where ($10) is the column of the goal (output) var


