#!/usr/bin/env perl

=head1 NAME

B<bencheval> - Evaluate a complex against models of it

=head1 SYNOPSIS

 bencheval true-complex-file.stor model1.stor model2.stor ...

=head1 DESCRIPTION



=head1 OPTIONS

=head2 -l|log=s     log level

=head2 -f|field=s   field name to sort on

=head2 -b|best=s    Best N (or N%) (per size, if -u)

=head2 -s|size=s    minimum N (or N%) components per model

=head2 -c|complete  Only full-coverage models

=head2 -r|reverse   reverse sort

=head2 -u|unique    unique by size (diff. sizes separately)

=head2 -h Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head1 SEE ALSO



=cut

################################################################################


use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use File::Basename;
use POSIX; # qw/ceil/;

use Data::Dump qw/dump/;
use Moose::Autobox;
use autobox ARRAY => 'SBG::U::List';

# TODO
# use SBG::Measure;
# Better: 
# use Statistics::Basic;
use SBG::U::List qw/mean sum/;

use SBG::Role::Storable;

# TODO DEL
use SBG::Run::rasmol qw/rasmol/;


################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
                        'l|log=s',   # log level
                        's|size=s',  # minimum N (or N%) components per model
                        'c|complete',# Only full-coverage models
                        'f|field=s', # field name to sort on
                        'b|best=s',  # Best N (or N%) (per size, if -u)
                        'r|reverse', # reverse sort
                        'u|unique',  # unique by size (diff. sizes separately)
    );                  

if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }
SBG::U::Log::init($ops{'l'}) if $ops{'l'};


# Score Fields
my @extrinsic = qw/target tsize model msize cover rmsd olap irmsd/;
my @intrinsic = qw/pval seqid eval sc glob/;
my @fields = (@extrinsic, @intrinsic);


# First file is the target/benchmark/true complex
my $targetfile = shift or pod2usage(-exitval=>1);
my $target = retrieve $targetfile;
# How much of the target complex do the models need to cover
my $minsize = _minsize($target, %ops);

my $tbase = basename($targetfile, '.stor');
my $tsize = $target->count;

# Keyed by size of models, list of observations (i.e. models) of that size
my $observations = [];


foreach my $modelfile (@ARGV) { 
    my $model = retrieve $modelfile;
    next unless defined($model);
    my $msize = $model->count;
    next if $msize < $minsize;
    my $mbase = basename($modelfile, '.stor');
    my ($mid) = $mbase =~ /-(\d+)$/;
    print STDERR "$mbase\n";
    my %obs = (
        target=>$tbase, tsize=>$tsize, model=>$mid, msize=>$msize,
        glob=>$model->globularity,
        cover=>1.0 * $msize / $tsize,
        _domain_scores($model),       # eval seqid
        _interaction_scores($model),  # irmsd zscore pval
        _superposition_scores($model),# sc
        );


    # Superpose model onto target
    # TODO BUG cannot transform model here, as it already has a transform
    # And it's not multiplied correctly.
    # So we have to transform target onto model

    my ($avgmat, $avgrmsd, ) = $model->superposition($target);
#     my ($avgmat, $avgrmsd, ) = $target->superposition($model);
#     my ($avgmat, $avgrmsd, ) = $target->superposition2($model);

#     $target->transform($avgmat);
    $model->transform($avgmat);


    rasmol [ @{$target->domains}, @{$model->domains} ];


    # Now that they're in one coordinate frame, get component-wise overlaps
    $obs{'olap'} = $model->overlap($target);
    # RMSD of centroids after superposition 
#     $obs{'rmsd'} = $model->rmsd($target);
    $obs{'rmsd'} = $avgrmsd;

    $obs{$_} *= 100.0 for (qw/cover glob olap/); # seqid/); # seqid already a %

    # Rewrite model file in target's frame of reference, for convenience later
#     my $io = SBG::DomainIO::stamp(file=>">${mbase}-sup.stor");
#     $io->write(@{$target->domains}, @{model->domains});

    $observations->push(\%obs);

} # foreach $modelfile


# Sort
if (my $f = $ops{'f'}) {
    $observations = [ sort { $a->{$f} <=> $b->{$f} } @$observations ];
    $observations = [ reverse @$observations ] if $ops{'r'};
}


# Only top N, or top N% ?
if (my $best = $ops{'b'}) {
    if ($best =~ /(\d+)\%$/) {
        $best = ceil(@$observations * $1 / 100.0);
    }
    $observations = @{$observations}[0..$best-1];
}


_print_csv($observations);


exit;


################################################################################
# target tsize model msize cover rmsd olap irmsd pval zscore seqid eval sc glob
sub _print_csv {
    my ($table) = @_;
    our $header;
    our $pattern;
    unless ($header) {
        $header = sprintf join(' ',
qw/%10s %5s %5s %5s %5s%%  %6s %4s%%  %7s %9s %5s%% %9s   %6s %4s%%/),
            @fields;
        $pattern = join(' ', 
qw/%10s %5d %5s %5d %6.f %6.3f %5.f %7.3f %9g  %6.f %9g %6.3f  %5.f/); 
        print "\n";
        print "$header\n";
    }

    foreach my $row (@$table) {
        # Print by fixed order given in @fields
        printf "$pattern\n", map { $row->{$_} } @fields;
    }
}


################################################################################
sub _minsize {
    my ($truth, %ops) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    my $minsize = $ops{'s'} || 3;
    # Only full-size (complete coverage) models?
    $minsize = '100%' if $ops{'c'};
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($truth->size() * $1 / 100.0);
    }
    return $minsize;
}


################################################################################
sub _domain_scores {
    my ($complex) = @_;
    my $models = $complex->models->values;
    
    my $ev = [];
    my $seqid = [];

    foreach my $model (@$models) {

        # fam superf and fold relations marked by 'REL' in eval
        my $e = $model->scores->at('eval');
        my $s = $model->scores->at('seqid');

        if (defined($e) && $e !~ /REL/) {
            $ev->push($e);
            $seqid->push($s);
        }
    }
    my %obs;
    $obs{'eval'} = $ev->sum || "NaN";
    $obs{'seqid'} = $seqid->mean || "NaN";
    return %obs;
} # _domain_scores


################################################################################
sub _interaction_scores {
    my ($complex) = @_;

    my $irmsd = [];
    my $zscore = [];
    my $pval = [];
    
    my $interactions = $complex->interactions->values;
    foreach my $interaction (@$interactions) {
        # Scores for interaction as a whole
        $irmsd->push($interaction->scores->at('irmsd'));
        $zscore->push($interaction->scores->at('zscore'));
        $pval->push($interaction->scores->at('pval'));

    }
    my %obs;
    $obs{irmsd} = $irmsd->mean || "NaN";
    $obs{zscore} = $zscore->mean || "NaN";
    $obs{pval} = $pval->sum || "NaN";
    return %obs;
} # _interaction_scores


################################################################################
sub _superposition_scores {
    my ($complex) = @_;
    
    # STAMP scores
    my $sc = [];
    
    my $superpositions = $complex->superpositions->values;
    foreach my $superposition (@$superpositions) {
        $sc->push($superposition->scores->at('Sc'));
    }
    my %obs;
    $obs{'sc'} = $sc->mean || "NaN";
    return %obs;
} # _superposition_scores



