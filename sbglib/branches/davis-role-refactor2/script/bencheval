#!/usr/bin/env perl

=head1 NAME

B<bencheval> - Evaluate a complex against models of it

=head1 SYNOPSIS

 bencheval true-complex-file.stor model1.stor model2.stor ...

=head1 DESCRIPTION



=head1 OPTIONS

=head2 -l|log=s     log level

=head2 -f|field=s   field name to sort on

=head2 -b|best=s    Best N (or N%) (per size, if -u)

=head2 -s|size=s    minimum N (or N%) components per model

=head2 -c|complete  Only full-coverage models

=head2 -r|reverse   reverse sort

=head2 -u|unique    unique by size (diff. sizes separately)

=head2 -h Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head1 SEE ALSO



=cut

################################################################################


use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use File::Basename;
use POSIX; # qw/ceil/;
use Carp;

use Data::Dump qw/dump/;
use Moose::Autobox;
use autobox ARRAY => 'SBG::U::List';

# TODO
# use SBG::Measure;
# Better: 
# use Statistics::Basic;
use SBG::U::List qw/mean sum/;

use SBG::Eval;
use SBG::Role::Storable;

use SBG::Run::rasmol qw/rasmol pdb2img/;
use SBG::DomainIO::stamp;
use SBG::DomainIO::pdb;

################################################################################



my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
                        'l|log=s',   # log level
                        's|size=s',  # minimum N (or N%) components per model
                        'c|complete',# Only full-coverage models
                        'f|field=s', # field name to sort on
                        'b|best=s',  # Best N (or N%) (per size, if -u)
                        'r|reverse', # reverse sort
                        'u|unique',  # unique by size (diff. sizes separately)
                        'd|debug',   # print stack trace on dead
    );                  

if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }
SBG::U::Log::init($ops{'l'}) if $ops{'l'};
$SIG{__DIE__} = \&confess if $ops{'d'};


# Score Fields
# TODO fields, range, formats, etc can all go in Eval class
my @extrinsic = qw/target tsize model msize cover rmsd olap irmsd/;
my @intrinsic = qw/pval seqid eval sc glob/;
my @fields = (@extrinsic, @intrinsic);
my $boundary = 4;
my @ranges = (
    ([]) x $boundary, # First fields are labels, no ranges
    [0,100 ], # cover
    [10,0  ], # rmsd
    [0,100 ], # olap
    [20,0  ], # irmsd
    [5,0   ], # pval
    [0,100 ], # seqid
    [1e-20,1e-100], # eval
    [0,10  ], # sc
    [0,100 ], # glob
    );


# First file is the target/benchmark/true complex
my $targetfile = shift or pod2usage(-exitval=>1);
my $target = retrieve $targetfile;
# How much of the target complex do the models need to cover
my $minsize = _minsize($target, %ops);

my $tbase = basename($targetfile, '.stor');
my $tsize = $target->count;

# Keyed by size of models, list of observations (i.e. models) of that size
my $observations = [];

mkdir($_) for qw/pdb ppm dom eval/;


foreach my $modelfile (@ARGV) { 
    my $mbase = basename($modelfile, '.stor');
    print STDERR "$mbase\n";
    my $evalfile = "eval/${mbase}.stor";

    my $ev = _load_eval($evalfile, $modelfile);

    $observations->push($ev);

    _outputs($evalfile, $modelfile, $target);


} # foreach $modelfile


# TODO This also needs to be wrapped in a report() sub

# Sort
if (my $f = $ops{'f'}) {
    $observations = [ sort { $a->{$f} <=> $b->{$f} } @$observations ];
    $observations = [ reverse @$observations ] if $ops{'r'};
}


# Only top N, or top N% ?
if (my $best = $ops{'b'}) {
    if ($best =~ /(\d+)\%$/) {
        $best = ceil(@$observations * $1 / 100.0);
    }
    $observations = @{$observations}[0..$best-1];
}


# _print_csv($observations, $tbase);
_print_html($observations, $tbase);


exit;


################################################################################
# target tsize model msize cover rmsd olap irmsd pval zscore seqid eval sc glob
sub _print_csv {
    my ($table, $tbase) = @_;
    our $header;
    our $pattern;
    unless ($header) {
        $header = sprintf join(' ',
qw/%10s %5s %5s %5s %5s%%  %6s %4s%%  %7s %9s %5s%% %12s %6s %4s%%/),
            @fields;
        $pattern = join(' ', 
qw/%10s %5d %5s %5d %6.f %6.3f %5.f %7.3f %9g  %6.f %12g %6.3f  %5.f/); 
        print "\n";
        print "$header\n";
    }

    foreach my $row (@$table) {
        # Print by fixed order given in @fields
        printf "$pattern\n", map { $row->{$_} } @fields;
    }
}

use CGI qw/:standard *table/;

# target tsize model msize cover rmsd olap irmsd pval zscore seqid eval sc glob

sub _print_html {
    my ($table, $tbase) = @_;
    
    print header if defined($ENV{GATEWAY_INTERFACE});
    print start_html($tbase);
    print start_table({-border=>'1'}, $tbase);

    my @htmlfields = (@fields, qw/pdb dom ppm/);
    print th([@htmlfields]);

    foreach my $row (@$table) {
        my $mbase = join('-', $row->{target}, 'model', $row->{model});
        
        $row->{rmsd} = sprintf("%.2f", $row->{rmsd});
        $row->{irmsd} = sprintf("%.2f", $row->{irmsd});
        $row->{sc} = sprintf("%.2f", $row->{sc});
        $row->{glob} = sprintf("%6.2f", $row->{glob}); 
        $row->{seqid} = sprintf("%6.2f", $row->{seqid}); 
        $row->{cover} = sprintf("%6.2f", $row->{cover}); 

        # Maintain order
        my @ordrow = map { $row->{$_} } @fields;

        my @tdrow = map { td($_) } @ordrow[0..$boundary-1];


        for (my $i = $boundary; $i < @ordrow; $i++) {
            my $color = mapcolor($ordrow[$i], @{$ranges[$i]});
            push @tdrow, td({-bgcolor=>$color}, $ordrow[$i]);
        }

       push 
           @tdrow, 
            td(a({-href=>"pdb/$mbase.pdb"}, 'pdb')), 
            td(a({-href=>"dom/$mbase.dom"}, 'dom')),
            td(({-href=>"ppm/$mbase.ppm"}, 'ppm')),
            ;
        print Tr({-align=>'right'}, "@tdrow"), "\n";
    }

    print end_html;
}


sub _load_eval {
    my ($evalfile, $modelfile) = @_;

    my $ev;
    if (-s $evalfile) {
#         print STDERR "$evalfile : already done\n";
        $ev = retrieve $evalfile;
        return $ev;
    }

    # Being computed by another process?
    my $lock = wlock($evalfile, 1);
    unless ($lock) {
        print STDERR "$evalfile : locked\n";
        return;
    }

    $ev = _eval_one($modelfile);
    if (! -s $evalfile) {
        $ev->store($evalfile);
        warn "evalfile written\n";
    }
    unlink $lock;
    return $ev;
}


sub _eval_one {
    my ($modelfile) = @_;

    my $model = retrieve $modelfile;
    next unless defined($model);
    my $msize = $model->count;
    next if $msize < $minsize;
    my $mbase = basename($modelfile, '.stor');
    my ($mid) = $mbase =~ /-(\d+)$/;

    my %obs = (
        target=>$tbase, tsize=>$tsize, model=>$mid, msize=>$msize,
        glob=>$model->globularity,
        cover=>1.0 * $msize / $tsize,
        _domain_scores($model),       # eval seqid
        _interaction_scores($model),  # irmsd zscore pval
        _superposition_scores($model),# sc
        );


    # Superpose model onto target
    # TODO BUG cannot transform model here, as it already has a transform
    # And it's not multiplied correctly.
    # So we have to transform target onto model

    my ($avgmat, $urmsd, $usc ) = $target->superposition_frame_cofm3($model);

    $target->transform($avgmat);

    $obs{avgmat} = $avgmat;

    # 'sc' field is already reserved for mean linker Sc score
#     $obs{'sc'} = $usc;

    # RMSD of centroids after superposition 
#     $obs{'rmsd'} = $model->rmsd($target);
    # Mean RMSD of componentwise superposition
#     $obs{rmsd} = $urmsd;
    # RMSD of crosshairs
    $obs{rmsd} = $target->rmsdonly($model);

    # Now that they're in one coordinate frame, get component-wise overlaps
    # TODO divide by 0 erorr
#     $obs{olap} = $model->overlap($target);
    $obs{olap} = 0;

    foreach (qw/cover glob olap/) {
        $obs{$_} = sprintf("%6.2f", 100.0 * $obs{$_}); 
    }
    # NB seqid/); # seqid already a %

    # Put the target back where it came from
    # TODO wouldnt be necessary if transforming the model would work ...
    $target->transform($avgmat->inv);


    return new SBG::Eval(%obs);


}


# STill want to save: mbase tbase targetfile modelfile 
sub _outputs {
    my ($evalfile, $modelfile, $target) = @_;

    my $mbase = basename($modelfile, '.stor');
    my $pdbfile = "pdb/${mbase}.pdb";
    my $domfile = "dom/${mbase}.dom";
    my $ppmfile = "ppm/${mbase}.ppm";
    my @files = ($pdbfile, $domfile, $ppmfile);
    my @locks = map { "$_.lock" } @files;
    my $alldone = 1;
    foreach (@files) {
        unless (-e $_ || -e "$_.lock") { $alldone = 0 }
    }
    return if $alldone;

    my $model = retrieve $modelfile;
    my $ev = retrieve $evalfile;
    my $avgmat = $ev->avgmat;

    # transform ...
    $target->transform($avgmat);

    _domfile($domfile, $model, $target);
    _pdbfile($pdbfile, $model, $target);
#     _ppmfile($mbase, $model, $target);

# TODO needed here?
    # Put the target back where it came from
    # TODO wouldnt be necessary if transforming the model would work ...
    $target->transform($avgmat->inv);

}



sub _domfile {
    my ($domfile, $model, $target) = @_;

    if (-s $domfile) {
#         print STDERR "$domfile already done\n";
        return;
    }
    my $lock = wlock($domfile, 1);
    unless ($lock) {
        print STDERR "$domfile : locked\n";
        return;
    }

    # Rewrite model file in target's frame of reference, for convenience later
    my $domio = new SBG::DomainIO::stamp(file=>">$domfile");
    $domio->write(@{$target->domains}, @{$model->domains});
    warn "$domfile written\n";
    unlink $lock;
}


sub _pdbfile {
    my ($pdbfile, $model, $target) = @_;

    if (-s $pdbfile) {
#         print STDERR "$pdbfile already done\n";
        return;
    }
    my $lock = wlock($pdbfile, 1);
    unless ($lock) {
        print STDERR "$pdbfile : locked\n";
        return;
    }

    my $targetasdom = $target->merge;
    my $modelasdom = $model->merge;

    # Rewrite model file in target's frame of reference, for convenience later
    my $pdbio = new SBG::DomainIO::pdb(file=>">$pdbfile");
    $pdbio->write($targetasdom, $modelasdom);
    warn "$pdbfile written\n";
    unlink $lock;
}


sub _ppmfile {
    my ($mbase, $model, $target) = @_;

    my $pdbfile = "pdb/${mbase}.pdb";
    my $ppmfile = "ppm/${mbase}.ppm";

    if (-s $ppmfile) {
#         print STDERR "$ppmfile already done\n";
        return;
    }
    my $lock = wlock($ppmfile, 1);
    unless ($lock) {
        print STDERR "$pdbfile : locked\n";
        return;
    }

    pdb2img(pdb=>$pdbfile, img=>$ppmfile);
    warn "$ppmfile written\n";
    unlink $lock;
}


################################################################################
sub _minsize {
    my ($truth, %ops) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    my $minsize = $ops{'s'} || 3;
    # Only full-size (complete coverage) models?
    $minsize = '100%' if $ops{'c'};
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($truth->size() * $1 / 100.0);
    }
    return $minsize;
}


################################################################################
sub _domain_scores {
    my ($complex) = @_;
    my $models = $complex->models->values;
    
    my $ev = [];
    my $seqid = [];

    foreach my $model (@$models) {

        # fam superf and fold relations marked by 'REL' in eval
        my $e = $model->scores->at('eval');
        my $s = $model->scores->at('seqid');

        if (defined($e) && $e !~ /REL/) {
            $ev->push($e);
            $seqid->push($s);
        }
    }
    my %obs;
    $obs{'eval'} = $ev->sum || "NaN";
    $obs{'seqid'} = $seqid->mean || "NaN";
    return %obs;
} # _domain_scores


################################################################################
sub _interaction_scores {
    my ($complex) = @_;

    my $irmsd = [];
    my $zscore = [];
    my $pval = [];
    
    my $interactions = $complex->interactions->values;
    foreach my $interaction (@$interactions) {
        # Scores for interaction as a whole
        $irmsd->push($interaction->scores->at('irmsd'));
        $zscore->push($interaction->scores->at('zscore'));
        $pval->push($interaction->scores->at('pval'));

    }
    my %obs;
    $obs{irmsd} = $irmsd->mean || "NaN";
    $obs{zscore} = $zscore->mean || "NaN";
    $obs{pval} = $pval->sum || "NaN";
    return %obs;
} # _interaction_scores


################################################################################
sub _superposition_scores {
    my ($complex) = @_;
    
    # STAMP scores
    my $sc = [];
    
    my $superpositions = $complex->superpositions->values;
    foreach my $superposition (@$superpositions) {
        $sc->push($superposition->scores->at('Sc'));
    }
    my %obs;
    $obs{'sc'} = $sc->mean || "NaN";
    return %obs;
} # _superposition_scores



sub wlock {
    my $file = shift or return;
    my $attempts = shift || 5;
    my $lock = "${file}.lock";
    until (symlink("$ENV{HOSTNAME}-$$", $lock)){
        $attempts--;
        return unless $attempts > 0;
        sleep 1 + int rand(3);
        my $full = rel2abs($lock);
        print STDERR "Waiting for lock: $full ($attempts)\n";
    }
    return $lock;
} # wlock


sub mapcolor {
    my ($val, $min, $max, $colora, $colorb) = @_;
    $colora ||= 0x33;
    $colorb ||= 0xff;
    my $mapped = maprange($val, $min, $max, $colora, $colorb);
    my $hex = sprintf("%x", $mapped);
    my $hexstr = '#' . ($hex x 3);
    return $hexstr;
}

sub maprange {
    my ($val, $min1, $max1, $min2, $max2) = @_;
    return interpolate( norm($val, $min1, $max1), $min2, $max2);
}
sub interpolate {
    my ($norm, $min, $max) = @_;
    return $min + ($max - $min) * $norm;
}
sub norm {
    my ($val, $min, $max) = @_;
    return ($val - $min) / ($max - $min);
}


