#!/usr/bin/env perl

=head1 NAME

B<assemble> - Assemble components into complexes

=head1 SYNOPSIS



=head1 DESCRIPTION


=head1 OPTIONS

=head2 -h|elp Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head2 -c|omplete

Only produce complex models that contain every component of the network

=head2 -s|ize

Minimum size of a complex model, in number of components, e.g.

 -s 4 (4 or more component proteins in complex models

 -s 75%$ (at least 75% of the components in the network are modelled)


=head1 SEE ALSO

L<SBG::CA::Assembler> , L<SBG::Network> , L<SBG::SearchI>

=cut

################################################################################

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Moose::Autobox;
use File::Basename;
use List::MoreUtils qw/each_arrayref/;
use POSIX;

use SBG::Role::Storable;
use SBG::Network;
use SBG::Traversal;
use SBG::CA::Assembler;
use SBG::Complex;

use SBG::U::Log;


################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
                        'c|complete',
                        's|size=s',
                        'l|log=s',
    );                  
if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }
SBG::U::Log::init($ops{'l'}) if $ops{'l'};


my $file = shift;
my $net = retrieve($file) or
    pod2usage(-exitval=>1, -verbose=>1, -message=>"$file is not an object");
my $basename = basename($file,'.stor');
print "Network: $basename\n";
_print_net($net);
my $minsize = _minsize($net, %ops);

# Assemble the network finally
_one_net($net, $basename, $minsize);

print "\n";
exit;


################################################################################
# Parse the -s command line option (minsize of complex predictions)
sub _minsize {
    my ($net, %ops) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    my $minsize = $ops{'s'} || 3;
    # Only full-size (complete coverage) models?
    $minsize = '100%' if $ops{'c'};
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($net->nodes() * $1 / 100.0);
    }
    return $minsize;
}


################################################################################
# 
sub _print_net {
    my ($net, $i, $n) = @_;
    $i ||= 1;
    $n ||= 1;
    printf 
        "\t%4d nodes, %4d edges, %4d interactions ...\n",
        scalar($net->vertices), scalar($net->edges), 
        scalar($net->interactions);
}


################################################################################
# Assemble network
sub _one_net {
    my ($net,$name, $minsize) = @_;

    # Traversal algorithm, on the network
    # -test is the function to call when trying to place an interaction
    # -partial is the function to call when one complex solution is complete
    my $t = new SBG::Traversal(graph=>$net, 
                               sub_test=>\&SBG::CA::Assembler::sub_test, 
                               sub_solution=>\&SBG::CA::Assembler::sub_solution,
                               minsize=>$minsize,
        );
    # Each result is a complex, this is a placeholder for the aglorithm's state
    my $state = new SBG::Complex(id=>$name);

    # Go!
    $t->traverse($state);

}



