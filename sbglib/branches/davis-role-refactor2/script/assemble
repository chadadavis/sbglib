#!/usr/bin/env perl

=head1 NAME

B<assemble> - Assemble components into complexes

=head1 SYNOPSIS



=head1 DESCRIPTION


=head1 OPTIONS

=head2 -h|elp Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head2 -c|omplete

Only produce complex models that contain every component of the network

=head2 -s|ize

Minimum size of a complex model, in number of components, e.g.

 -s 4 (4 or more component proteins in complex models

 -s 75%$ (at least 75% of the components in the network are modelled)


=head1 SEE ALSO

L<SBG::CA::Assembler> , L<SBG::Network> , L<SBG::SearchI>

=cut

################################################################################

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Moose::Autobox;
use File::Basename;
use List::MoreUtils qw/each_arrayref/;
use POSIX;

use SBG::Role::Storable;
use SBG::Network;
use SBG::Traversal;
use SBG::CA::Assembler;
use SBG::Complex;

use SBG::U::Log;


################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
                        'c|complete',
                        's|size=s',
                        'l|log=s',
    );                  
if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }
SBG::U::Log::init($ops{'l'}) if $ops{'l'};


my $file = shift;
my $net = retrieve($file) or
    pod2usage(-exitval=>1, -verbose=>1, -message=>"$file is not an object");
my $basename = basename($file,'.stor');

_print_net($basename, $net);
my $minsize = _minsize($net, %ops);

my $donefile = "${basename}.done";


if (-s "${basename}.done") {
    my $d = `cat ${basename}.done`;
    chomp $d;
    printf "%5d already done\n", $d;
    exit;
}

my $lock = wlock($donefile, 1);
unless ($lock) {
    print "\tlocked\n";
    exit;
}

_one_net($net, $basename, $minsize);
print "\n";
my @done = <${basename}*.stor>;
my $done = scalar(@done);
`echo $done > ${basename}.done`;
unlink $lock;


exit;


################################################################################
# Parse the -s command line option (minsize of complex predictions)
sub _minsize {
    my ($net, %ops) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    my $minsize = $ops{'s'} || 3;
    # Only full-size (complete coverage) models?
    $minsize = '100%' if $ops{'c'};
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($net->nodes() * $1 / 100.0);
    }
    return $minsize;
}


################################################################################
# 
sub _print_net {
    my ($basename, $net, $i, $n) = @_;
    $i ||= 1;
    $n ||= 1;
    printf 
        "%-20s %4d nodes, %4d edges, %4d interactions \n",
        $basename,
        scalar($net->vertices), scalar($net->edges), 
        scalar($net->interactions);
}


################################################################################
# Assemble network
sub _one_net {
    my ($net,$name, $minsize) = @_;

    # Traversal algorithm, on the network
    # -test is the function to call when trying to place an interaction
    # -partial is the function to call when one complex solution is complete
    my $t = new SBG::Traversal(graph=>$net, 
                               sub_test=>\&SBG::CA::Assembler::sub_test, 
                               sub_solution=>\&SBG::CA::Assembler::sub_solution,
                               minsize=>$minsize,
        );
    # Each result is a complex, this is a placeholder for the aglorithm's state
    my $state = new SBG::Complex(id=>$name);

    # Go!
    $t->traverse($state);

}


=head2 wlock

 Title   : wlock
 Usage   : my $lockfile = wlock("file.txt", 10); unlink $lockfile;
 Function: Sets a lock (as symlink) on the given file
 Returns : The link to the lock file, if it could be created, otherwise nothing
 Args    : The file that is to be exclusively opened.
           The number of attempts to try to lock the file. Default 5.

Routine fails, returning nothing, if it cannot create the lock within the given
number of attempts.

If you to test a lock without waiting, just set the number of attempts to 1.
Otherwise the function will sleep for a second between each attempt to give any
other processes a chance to finish what they are doing before attempting to lock
the file again.

The lock file returned by this method must be deleted by the caller after the
lock is no longer needed. E.g.:

my $database = "mydatabase.dat";
my $lockfile = wlock($database);
open (DB, ">$database");
# Read or write the file
close DB;
# Release the lock, so that other processes can access the data file
unlink $lockfile;

=cut
use File::Spec::Functions qw/rel2abs/;
sub wlock {
    my $file = shift or return;
    my $attempts = shift || 5;
    my $lock = "${file}.lock";
    until (symlink("$ENV{HOSTNAME}-$$", $lock)){
        $attempts--;
        return unless $attempts > 0;
        sleep 1 + int rand(3);
        my $full = rel2abs($lock);
        print STDERR "Waiting for lock: $full ($attempts)\n";
    }
    return $lock;
} # wlock


