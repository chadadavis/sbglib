#!/usr/bin/env perl

=head1 NAME

B<bencheval> - Evaluate a complex against models of it

=head1 SYNOPSIS

 bencheval <true-complex.sto>r <model1.stor> [model2.stor ...]

=head1 DESCRIPTION



=head1 OPTIONS

=head2 -l|log=s     log level

=head2 -f|field=s   field name to sort on

=head2 -b|best=s    Best N (or N%) (per size, if -u)

=head2 -s|size=s    minimum N (or N%) components per model

=head2 -c|complete  Only full-coverage models

=head2 -r|reverse   reverse sort

=head2 -u|unique    unique by size (diff. sizes separately)

=head2 -h Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head1 SEE ALSO



=cut

################################################################################


use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use File::Basename;
use File::Spec qw/rel2abs/;
use POSIX; # qw/ceil/;
use Carp;
use CGI qw/:standard *table/;
use Data::Dump qw/dump/;
use Moose::Autobox;
use autobox ARRAY => 'SBG::U::List';

use File::NFSLock;
use Fcntl qw/LOCK_EX LOCK_NB/;

use SBG::U::List qw/mean avg median sum min max flatten argmax argmin/;

# use SBG::Eval;
use SBG::Role::Storable;
use SBG::U::HTML qw/formattd rcsb/;

use SBG::Seq; # required to reinstate overload on SBG::PrimarySeqI
use SBG::Run::rasmol qw/rasmol pdb2img/;
use SBG::DomainIO::stamp;
use SBG::DomainIO::pdb;
use SBG::InteractionIO::html;
use SBG::SuperpositionIO::html;
use SBG::U::Log;

################################################################################

my %ops;
my $result = GetOptions(\%ops,
                        'help|h',
                        'loglevel|l=s',   # log level
                        'logfile=s',      # log file
                        'debug|d',        # print stack trace when die
                        'output|o',       # html or csv
                        'size|s=s',       # minimum N (or N%) components/model
                        'complete|c',     # Only full-coverage models
                        'field|f=s',      # field name to sort on
                        'thresh|t=f',     # min threshold val for field
                        'best|b=s',       # Best N (or N%) (per size, if -u)
                        'reverse|r',      # reverse sort
                        'minseqid|n=f',   # minimum seqid to allow
                        'maxseqid|x=f',   # maximum seqid to allow
    );                  


if ($ops{'help'}) { pod2usage(-exitval=>1, -verbose=>2); }

$SIG{__DIE__} = \&confess if $ops{'debug'};
$ops{'size'} = '100%' if $ops{'complete'};

# Sort descending on Sc by default
unless (defined $ops{'field'}) {
    $ops{'field'} ||= 'medsc';
    $ops{'reverse'} = 1; # Descending
    $ops{'thresh'} = 5.0;
}

mkdir 'eval';
mkdir("eval/$_") for qw/log pdb dom html/;

my @idxkeys = 
    qw/target nmodels ngood model msize rmsd medsc iface seqids superpos/;
my @allkeys = qw/target model msize rmsd medsc iface seqids superpos/;


# First file is the target/benchmark/true complex
my $targetfile = shift or pod2usage(-exitval=>1);

my $basename = basename($targetfile,'.target');
$ops{'logfile'} ||= "eval/log/${basename}.log";
SBG::U::Log::init($basename, %ops);


# Evaluate all other files as models, against target
my ($best, $all) = evaltarget(\%ops, $targetfile, @ARGV) or exit;

my $tbase = basename($targetfile, '.target');
my ($pdb) = $tbase =~ /^(.{4})/;
$best->{'target'} = a({-href=>"${tbase}.html"},$tbase);

my $idxrow = td([map { $best->{$_} } @idxkeys ]);
my ($idxfh,$idxlock) = openidxhtml(@idxkeys);
print $idxfh Tr($idxrow);
close $idxfh;
$idxlock->unlock;

if (0) {
my @allrows = map { my $m=$_; td([map { $m->{$_} } @allkeys ]) } @$all;
my $allrow = Tr(\@allrows);
my ($allfh, $alllock) = openallhtml(@allkeys);
print $allfh Tr($allrow);
close $allfh;
$alllock->unlock;
}

exit;


################################################################################

sub openidxhtml {
    my (@keys) = @_;
    my $file = "eval/html/index.html";
    my $lock = File::NFSLock->new($file,LOCK_EX,60,5*60);
    unless ($lock) {
        warn "Could not lock for writing: $file";
        return;
    }
    if (-s $file) {
        open my $fh, ">>$file";
        return wantarray ? ($fh, $lock) : $fh;
    } else {
        open my $fh, ">$file";
        print $fh start_html("Top models");
        print $fh h2("Top models, by target"), "\n";
        print $fh start_table({-border=>'1'});
        print $fh Tr(th([ @keys ]));
        return wantarray ? ($fh, $lock) : $fh;
    }
}


sub openallhtml {
    my (@keys) = @_;
    my $file = "eval/html/all.html";
    my $lock = File::NFSLock->new($file,LOCK_EX,60,5*60);
    unless ($lock) {
        warn "Could not lock for writing: $file";
        return;
    }
    if (-s $file) {
        open my $fh, ">>$file";
        return wantarray ? ($fh, $lock) : $fh;
    } else {
        open my $fh, ">$file";
        print $fh start_html("All models");
        print $fh h2("All models"), "\n";
        print $fh start_table({-border=>'1'});
        print $fh Tr(th([ @keys ]));
        return wantarray ? ($fh, $lock) : $fh;
    }
}


sub opencorrcsv {
    my ($corrfile) = @_;
    $corrfile ||= 'eval/rmsdcorr.csv';
    if (my $lock = File::NFSLock->new($corrfile,LOCK_EX,100,5*60)) {
        unless (-s $corrfile) {
            open my $rmsdfh, ">>$corrfile";
            printf 
                $rmsdfh join('','#',("%10s")x5,"\n"),
                qw/target model rmsd medsc iface/;
        }
        # Otherwise it's already been opened and header was already written
    } else {
        warn "Could not lock for writing: $corrfile";
    }
}


sub evaltarget {
    my $ops = {};
    $ops = shift(@_) if ref($_[0]) eq 'HASH';
    my ($targetfile, @modelfiles) = @_;

    # Needed because this might just be a file glob when no files present
    return unless -f $modelfiles[0];

    my $target = retrieve($targetfile);
    unless (defined $target) {
        warn "No target in: $targetfile\n";
        return;
    }

# TODO DEL
# Hack to compensate for STAMP lowercasing chain IDs
#     foreach my $k ($target->keys->flatten) {
#         my $lck = lc $k;
#         $target->set($lck, $target->get($k));
#         $target->models->delete($k);
#     }


    # How much of the target complex do the models need to cover
    my $tsize = $target->count;
    # Convert possible size% to integer 
    $ops->{'size'} = _minsize($tsize, $ops->{'size'});

    my $tbase = basename($targetfile, '.target');
    # Output for all models on this target
    my $file = "eval/html/${tbase}.html";
    open my $fh, ">$file";

    print $fh start_html($tbase);
    print $fh h2(rcsb("Target $tbase")), "\n";
    print $fh start_table({-border=>'1'});
    my @keys = qw/model msize rmsd medsc iface seqids superpos/;
    print $fh Tr(th([ @keys ]));

    my $evmodels = [];

    my $corrfile = 'eval/rmsdcorr.csv';
    opencorrcsv($corrfile);

    foreach my $modelfile (@modelfiles) { 
        my %ev = evalmodel($ops, $target, $modelfile) or next;
        my $row = td([map { $ev{$_} } @keys ]);
        print $fh Tr($row);

        my ($pdb) = $tbase =~ /^(.{4})/;
        $ev{'target'} = a({-href=>"${tbase}.html"},$pdb);
        $evmodels->push({%ev});

        my @fields = map { $ev{$_} } qw/rmsd medsc iface/;
        
        if (my $lock = File::NFSLock->new($corrfile,LOCK_EX,100,5*60)) {
            open my $rmsdfh, ">>$corrfile";
            my ($mid) = $modelfile =~ /model-(.*?).model$/;
            printf 
                $rmsdfh join('',("%10s")x5, "\n"),
                $tbase,$mid, @fields;
        } else {
            warn "Cannot lock for writing: $corrfile";
        }
    } # foreach $modelfile

    print $fh end_table();
    close $fh;

    my $field = $ops->{'field'};
    my $best = $ops->{'reverse'} ? 
        argmax { $_->{$field} } @$evmodels : # Descending, i.e. want max
        argmin { $_->{$field} } @$evmodels;  # Ascending, i.e. want min

    # Addtl stats (over all models)
    $best->{'nmodels'} = $evmodels->length;
    my $subgood = sub{!($_->{$field}<$ops->{'thresh'})&&$_->{'cover'}>=50};
    my @good = grep { $subgood->($_) } @$evmodels;
    $best->{'ngood'} = scalar(@good);

    return $best, $evmodels;

} # evaltarget


################################################################################
sub evalmodel {
    my $ops = {};
    $ops = shift(@_) if ref($_[0]) eq 'HASH';
    my ($target, $modelfile) = @_;
    return unless -f $modelfile;
    my $model = retrieve $modelfile;

    my $mbase = basename($modelfile, '.model');
    my $file = "eval/html/${mbase}.html";
    open my $fh, ">$file";
    print $fh start_html($mbase);
    print $fh h2("Model $mbase"), "\n";
    print $fh start_table({-border=>'1'});
    my @keys = qw/target superpos dom rmsd cover msize tsize glob nres medsc iface seqids/;
    print $fh Tr(th([ @keys ]));

    my %ev = (base=>$mbase);
    my ($tlabel, $mid) = $mbase =~ /(.*?)-model-(.*?)/;
    my ($tpdb) = $tlabel =~ /^(.{4})/;
    $ev{'target'} = a({-href=>"${tlabel}.html"},$tlabel);

    return unless defined($model);
    return if $model->count < $ops->{'size'};

    modelstats(\%ev, $target, $model);
    modellinks(\%ev);
    modeloutputs(\%ev, $target, $model);

    my @seqids = @{$ev{'seqids'} || []};

    # skip if seqid thresh not met
    return if defined($ops->{'minseqid'}) && ! $seqids[0] >= $ops->{'minseqid'};
    return if defined($ops->{'maxseqid'}) && ! $seqids[1] <= $ops->{'maxseqid'};
    $ev{'seqids'} = join('-', @seqids);

    my $row = td([map { $ev{$_} } @keys]);
    print $fh Tr($row);
    print $fh end_table();

    my $iactionio = new SBG::InteractionIO::html(fh=>$fh);
    $iactionio->write($model->interactions->values);
    my $supio = new SBG::SuperpositionIO::html(fh=>$fh);
    $supio->write($model->superpositions->values);

    close $fh;

    # Save any changes
    $model->store($modelfile);    
    return %ev;
}


sub modellinks {
    my ($ev) = @_;
    my $base = $ev->{base};

    my ($targetlabel, $mid) = $base =~ /^(.*?)-model-(.*?)$/;
    $ev->{'model'} = a({-href=>"${base}.html"}, $mid);
    $ev->{'dom'} = a({-href=>"../dom/${base}.dom"}, 'dom');
    $ev->{'superpos'} = a({-href=>"../pdb/${base}.pdb.gz"}, 'superpos');
}


################################################################################
sub modelstats {
    my ($ev, $target, $model) = @_;

    my ($rmsd, $trans) = modelrmsd($model, $target);
        
    $ev->{'rmsd'} = $rmsd ? sprintf("%.2f", $rmsd) : 'NaN';
    $ev->{'trans'} = $trans if defined $trans;
    $ev->{'cover'} = sprintf "%6.2f", 100.0 * $model->count / $target->count;
    $ev->{'msize'} = $model->count;
    $ev->{'tsize'} = $target->count;
    $ev->{'glob'} = sprintf "%6.2f", $model->globularity;
    $ev->{'nres'} = $model->domains->map(sub {$_->length})->sum;

    my $scs = $model->superpositions->values->map(sub{$_->scores->at('Sc')});
    $ev->{'medsc'} = sprintf "%.2f", $scs->median;

    my $iactions = $model->interactions->values;
    my $models = $iactions->map(sub{ flatten $_->models->values });
    my $seqids = $models->map(sub{$_->scores->at('seqid')});
    $seqids = $seqids->map(sub{ isalpha($_) ? 0 : sprintf("%d",$_) });
    my @seqids = sort { $a <=> $b } @$seqids;
    $ev->{'seqids'} = [ shift(@seqids), pop(@seqids) ];

    my $iface_cons = $iactions->map(sub{
        $_->scores->at('interface_conserved')});
    $ev->{'iface'} = sprintf "%.2f", $iface_cons->median;

# TODO
#     * avg clash %

}


################################################################################

sub modelrmsd {
    my ($model, $target) = @_;

    my $benchrmsd;
    my $benchmatrix;
    if ($model->scores->exists('benchrmsd')) {
        $benchrmsd = $model->scores->at('benchrmsd');
        $benchmatrix = $model->scores->at('benchmatrix');
    } else {
        ($benchmatrix, $benchrmsd) = $model->rmsd($target);
        $model->transform($benchmatrix) if defined $benchmatrix;
        $benchrmsd = 'NaN' unless defined $benchrmsd;
        $model->scores->put('benchrmsd', $benchrmsd);
        $model->scores->put('benchmatrix', $benchmatrix);
    }
    return wantarray ? ($benchrmsd, $benchmatrix) : $benchrmsd;
}


################################################################################
sub _sort {
    my ($observations, $field, $reverse) = @_;
    return $observations unless $field;
    $observations = [ sort { $a->{$field} <=> $b->{$field} } @$observations ];
    $observations = [ reverse @$observations ] if $reverse;
    return $observations;
}


################################################################################
# Only top N, or top N% ?
# Assuming $observations already sorted
sub _top {
    my ($observations, $best) = @_;
    return $observations unless $best;
    if ($best =~ /(\d+)\%$/) {
        $best = ceil(@$observations * $1 / 100.0);
    }
    $observations = @{$observations}[0..$best-1];
    return $observations;
}



################################################################################
# target tsize model msize cover rmsd olap irmsd pval zscore seqid eval sc glob
sub _print_html {
    my ($table, $tbase) = @_;
    our @fields;
    our $boundary = 4;
    our @ranges;

    print header if defined($ENV{GATEWAY_INTERFACE});
    print start_html($tbase);
    print start_table({-border=>'1'}, $tbase);

    my @htmlfields = (@fields, qw/pdb dom/);
    print th([@htmlfields]);

    foreach my $row (@$table) {
        my $mbase = join('-', $row->{target}, 'model', $row->{model});
        
        $row->{rmsd} = sprintf("%.2f", $row->{rmsd});
        $row->{irmsd} = sprintf("%.2f", $row->{irmsd});
        $row->{sc} = sprintf("%.2f", $row->{sc});
        $row->{glob} = sprintf("%6.2f", $row->{glob}); 
        $row->{seqid} = sprintf("%6.2f", $row->{seqid}); 
        $row->{cover} = sprintf("%6.2f", $row->{cover}); 

        # Maintain order
        my @ordrow = map { $row->{$_} } @fields;

        my @tdrow = map { td($_) } @ordrow[0..$boundary-1];


        for (my $i = $boundary; $i < @ordrow; $i++) {
            my $color = mapcolor($ordrow[$i], @{$ranges[$i]});
            push @tdrow, td({-bgcolor=>$color}, $ordrow[$i]);
        }

       push 
           @tdrow, 
            td(a({-href=>"../pdb/$mbase.pdb.gz"}, 'pdb')), 
            td(a({-href=>"../dom/$mbase.dom"}, 'dom')),
            ;
        print Tr({-align=>'right'}, "@tdrow"), "\n";
    }

    print end_html;
} # _print_html


sub modeloutputs {
    my ($ev, $target, $model) = @_;

    my $mbase = $ev->{base};
    my $pdbfile = "eval/pdb/${mbase}.pdb.gz";
    my $domfile = "eval/dom/${mbase}.dom";
    my @files = ($pdbfile, $domfile);
    my @locks = map { "$_.NFSLock" } @files;
    my $alldone = 1;
    foreach (@files) {
        unless (-e $_ || -e "$_.NFSLock") { $alldone = 0 }
    }
    return if $alldone;

    _domfile($domfile, $model, $target);
    _pdbfile($pdbfile, $model, $target);

} # modeloutput


sub _domfile {
    my ($domfile, $model, $target) = @_;

    if (-s $domfile) {
#         print STDERR "$domfile already done\n";
        return;
    }
    my $lock = File::NFSLock->new($domfile,LOCK_EX|LOCK_NB) or return;

    my $domio = new SBG::DomainIO::stamp(file=>">$domfile");
    $domio->write(@{$model->domains});
    if ($model->scores->at('benchrmsd') > 0) {
        my $keys = $model->coverage($target);
        $domio->write(@{$target->domains($keys)});
    }
}


sub _pdbfile {
    my ($pdbfile, $model, $target) = @_;

    my $lock = File::NFSLock->new($pdbfile,LOCK_EX|LOCK_NB) or return;

    my @doms;
    # If there was a superposition onto the target, show it as well
    if ($model->scores->at('benchrmsd') > 0) {

        # Treat model complex as single domain
        my $modelasdom = $model->merge;
        push @doms, $modelasdom;

        # Only show common components
        my $keys = $model->coverage($target);
        # Get target complex as single domain
        push @doms, $target->merge(keys=>$keys);
    } else {
        push @doms, $model->domains->flatten;
    }

    my $pdbio = new SBG::DomainIO::pdb(file=>">${pdbfile}", compressed=>1);
    $pdbio->write(@doms);

}


################################################################################
sub _minsize {
    my ($totalsize, $minsize, $complete) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    $minsize = 3 unless defined $minsize;

    # Only full-size (complete coverage) models?
    $minsize = '100%' if $complete;
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($totalsize * $1 / 100.0);
    }
    return $minsize;
}


################################################################################
sub _domain_scores {
    my ($complex) = @_;
    my $models = $complex->models->values;
    
    my $ev = [];
    my $seqid = [];

    foreach my $model (@$models) {

        # fam superf and fold relations marked by 'REL' in eval
        my $e = $model->scores->at('eval');
        my $s = $model->scores->at('seqid');

        if (defined($e) && $e !~ /REL/) {
            $ev->push($e);
            $seqid->push($s);
        }
    }
    my %obs;
    $obs{'eval'} = $ev->sum || "NaN";
    $obs{'seqid'} = $seqid->mean || "NaN";
    return %obs;
} # _domain_scores


################################################################################
sub _interaction_scores {
    my ($complex) = @_;

    my $irmsd = [];
    my $zscore = [];
    my $pval = [];
    
    my $interactions = $complex->interactions->values;
    foreach my $interaction (@$interactions) {
        # Scores for interaction as a whole
        $irmsd->push($interaction->scores->at('irmsd'));
        $zscore->push($interaction->scores->at('zscore'));
        $pval->push($interaction->scores->at('pval'));

    }
    my %obs;
    $obs{irmsd} = $irmsd->mean || "NaN";
    $obs{zscore} = $zscore->mean || "NaN";
    $obs{pval} = $pval->sum || "NaN";
    return %obs;
} # _interaction_scores


################################################################################
sub _superposition_scores {
    my ($complex) = @_;
    
    # STAMP scores
    my $sc = [];
    
    my $superpositions = $complex->superpositions->values;
    foreach my $superposition (@$superpositions) {
        $sc->push($superposition->scores->at('Sc'));
    }
    my %obs;
    $obs{'sc'} = $sc->mean || "NaN";
    return %obs;
} # _superposition_scores



sub mapcolor {
    my ($val, $min, $max, $colora, $colorb) = @_;
    $colora ||= 0x33;
    $colorb ||= 0xff;
    my $mapped = maprange($val, $min, $max, $colora, $colorb);
    my $hex = sprintf("%x", $mapped);
    my $hexstr = '#' . ($hex x 3);
    return $hexstr;
}

sub maprange {
    my ($val, $min1, $max1, $min2, $max2) = @_;
    return interpolate( norm($val, $min1, $max1), $min2, $max2);
}
sub interpolate {
    my ($norm, $min, $max) = @_;
    return $min + ($max - $min) * $norm;
}
sub norm {
    my ($val, $min, $max) = @_;
    return ($val - $min) / ($max - $min);
}


