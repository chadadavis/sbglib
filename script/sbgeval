#!/usr/bin/env perl

=head1 NAME

B<sbgeval> - Evaluate a complex against models of it

=head1 SYNOPSIS

 sbgeval true-complex-file.stor model1.stor model2.stor ...

=head1 DESCRIPTION


=head1 OPTIONS

=head2 -h Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head1 SEE ALSO



=cut

################################################################################


use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Moose::Autobox;
use autobox ARRAY => 'SBG::List';
use File::Basename;
use POSIX;

# TODO
# use SBG::Measure;
use SBG::List qw/mean/;

use SBG::Complex;
use SBG::Storable;

################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
                        'l|log=s',
                        's|size=s',
                        'c|complete',
                        'f|field=s',
                        'b|best=s',
                        'r|reverse',
    );                  
if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }

SBG::Log::init($ops{'l'}) if $ops{'l'};


################################################################################

my $truthfile = shift or pod2usage(-exitval=>1);
my $truth = retrieve $truthfile;
our $minsize = _minsize($truth, %ops);

my @fields = qw/PDB Benchmark BN Model MN Iact Cover RMSD Olap iRMSD i2Z i2P i2E i2SID Sc RMS Al Fit Eq %I %S P(m)/;

my $header  = sprintf 
    "#%3s %20s %4s %40s %4s %4s %6s %5s %6s %5s %7s %12s %12s %6s %5s %5s %4s %4s %4s %6s %6s %12s\n",
    @fields;
print $header;

# Data line pattern
my $pattern = 
    "%4s %20s %4d %40s %4d %4d %6.2f %5.2f %6.2f %5.2f %7.3f %12g %12g %6.2f %5.2f %5.2f %4d %4d %4d %6.2f %6.2f %12g\n";

my @observations;

foreach my $modelfile (@ARGV) { 
    my $model = retrieve $modelfile;
    next unless defined($model);
    next if $model->size < $minsize;

    my %obs = (_iaction_scores($model), _linker_scores($model));

    # RMSD between model and complex
    $obs{RMSD} = $model->min_rmsd($truth) || 'nan';

    # linear overlap of spheres (cofm+rg) (as % of maximum possible overlap)
    my $overlap = $model->overlap($truth);
    $overlap *= 100 if defined $overlap;
    $obs{Olap} = $overlap || 'nan';

    # Sizes and coverage
    $obs{PDB} = basename($ENV{PWD});
    $obs{Benchmark} = $truthfile;
    $obs{BN} = $truth->size;
    $obs{Model} = $modelfile;
    $obs{MN} = $model->size;
    $obs{Cover} = 100 * $model->size/$truth->size;

    push @observations, \%obs;
}


# Sort
if (my $f = $ops{'f'}) {
    @observations = sort { $a->{$f} <=> $b->{$f} } @observations;
    @observations = reverse(@observations) if $ops{'r'};
}


my $best = $ops{'b'} || '100%';
if ($best =~ /(\d+)\%$/) {
    $best = ceil(@observations * $1 / 100.0);
}

# Print
for (my $i = 0; $i < @observations; $i++) {
    last if $i >= $best;
    my $obs = $observations[$i];
    # Print %obs by order given in @fields
    printf $pattern, map { $obs->{$_} } @fields;
}

exit;

################################################################################


sub _minsize {
    my ($truth, %ops) = @_;
    # Min components in complex (e.g. 4 or '75%' )
    my $minsize = $ops{'s'} || 3;
    # Only full-size (complete coverage) models?
    $minsize = '100%' if $ops{'c'};
    if ($minsize =~ /(\d+)\%$/) {
        $minsize = ceil($truth->size() * $1 / 100.0);
    }
    return $minsize;
}


sub _iaction_scores {
    my ($model) = @_;
    my %obs;

    my $iRMSD = [];
    my $i2Z = [];
    my $i2P = [];
    my $i2E = [];
    my $i2SID = [];

    my $iaction_keys = $model->interactions->keys;
    foreach my $iaction_key (@$iaction_keys) {
        my $interaction = $model->interaction($iaction_key);
        # Scores for interaction as a whole
        $iRMSD->push($interaction->score('irmsd'));
        $i2Z->push($interaction->score('zscore'));
        $i2P->push($interaction->score('pval'));

        # Score for each half of interaction
        my $template_keys = $interaction->templates->keys;
        foreach my $template_key (@$template_keys) {
            my $template = $interaction->template($template_key);
            # fam superf and fold relations marked by 'REL' in eval
            if ($template->score('eval') !~ /REL/) {
                $i2E->push($template->score('eval'));
                $i2SID->push($template->score('seqid'));
            }
        }
    }
    $obs{Iact} = scalar(@$iaction_keys);
    $obs{iRMSD} = ($iRMSD->mean || 'nan');
    $obs{i2Z} = ($i2Z->mean || 'nan');
    $obs{i2P} = ($i2P->mean || 'nan');
    $obs{i2E} = ($i2E->mean || 'nan'); 
    $obs{i2SID} = ($i2SID->mean || 'nan');
    return %obs;
} # _iaction_scores


sub _linker_scores {
    my ($model) = @_;
    my %obs;

    # STAMP scores
    my $Sc = [];
    my $RMS = [];
    my $Al = [];
    my $Fit = [];
    my $Eq = [];
    my $I = [];
    my $S = [];
    my $P = [];

    my $domain_keys = $model->models->keys;
    foreach my $domain (@$domain_keys) {
        my $l = $model->model($domain)->linker;

        $Sc->push($l->{'Sc'});
        $RMS->push($l->{'RMS'});
        $Al->push($l->{'Align'});
        $Fit->push($l->{'Fit'});
        $Eq->push($l->{'Eq'});
        $I->push($l->{'I'});
        $S->push($l->{'S'});
        $P->push($l->{'P'});
    }
    $obs{'Sc'} = ($Sc->mean() || 'nan');
    $obs{'RMS'} = ($RMS->mean || 'nan');
    $obs{'Al'} = ($Al->mean || 'nan');
    $obs{'Fit'} = ($Fit->mean || 'nan');
    $obs{'Eq'} = ($Eq->mean || 'nan');
    $obs{'%I'} = ($I->mean || 'nan');
    $obs{'%S'} = ($S->mean || 'nan');
    $obs{'P(m)'} = ($P->mean || 'nan');
    return %obs;
} # _linker_scores

__END__


