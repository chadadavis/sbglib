#!/usr/bin/env perl

=head1 NAME

B<sbgeval> - Evaluate a complex against models of it

=head1 SYNOPSIS

 sbgeval true-complex-file.stor model1.stor model2.stor ...

=head1 DESCRIPTION


=head1 OPTIONS

=head2 -h Print this help page

=head2 -l|og Set logging level

In increasing order: TRACE DEBUG INFO WARN ERROR FATAL

I.e. setting B<-l WARN> (the default) will log warnings errors and fatal
messages, but no info or debug messages to the log file (B<log.log>)

=head1 SEE ALSO



=cut

################################################################################


use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Moose::Autobox;
use autobox ARRAY => 'SBG::List';
use File::Basename;

# TODO
# use SBG::Measure;
use SBG::List qw/mean/;

use SBG::Complex;
use SBG::Storable;

################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
                        'l|log=s',
    );                  
if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }

SBG::Log::init($ops{'l'}) if $ops{'l'};


################################################################################

my $truthfile = shift or pod2usage(-exitval=>1);
my $truth = retrieve $truthfile;

my $pattern = 
    "%4s %20s %3d %40s %3d %4d %6.2f %5.2f %6.2f %5.2f %7.3f %12g %12g %6.2f %5.2f %5.2f %4d %4d %4d %6.2f %6.2f %12g\n";
my $header  = sprintf 
    "#%3s %20s %3s %40s %3s %4s %6s %5s %6s %5s %7s %12s %12s %6s %5s %5s %4s %4s %4s %6s %6s %12s\n",
    qw/PDB Benchmark N Model N Iact Cover RMSD Olap iRMSD i2Z i2P i2E i2SID Sc RMS Al Fit Eq %I %S P(m)/;

print $header;


foreach my $modelfile (@ARGV) { 
    my $model = retrieve $modelfile;
    next unless defined($model);
    my $min_rmsd = $model->min_rmsd($truth) || 'nan';
    # This will only work on *very* similar complexes
#     my $crmsd = $model->complexrmsd($truth) || 'nan';

    # linear overlap of spheres (cofm+rg) (as % of maximum possible overlap)
    my $overlap = $model->overlap($truth);
    $overlap *= 100 if defined $overlap;

    my $irmsds = [];
    my $zscores = [];
    my $pvals = [];
    my $evals = [];
    my $seqids = [];


    my $iaction_keys = $model->interactions->keys;
    foreach my $iaction_key (@$iaction_keys) {
        my $interaction = $model->interaction($iaction_key);
        $irmsds->push($interaction->score('irmsd'));
        $zscores->push($interaction->score('zscore'));
        $pvals->push($interaction->score('pval'));

        my $template_keys = $interaction->templates->keys;
        foreach my $template_key (@$template_keys) {
            my $template = $interaction->template($template_key);
            # fam superf and fold relations marked by 'REL' in eval
            if ($template->score('eval') !~ /REL/) {
                $evals->push($template->score('eval'));
                $seqids->push($template->score('seqid'));
            }
        }
    }

    # STAMP scores
    my $Scs = [];
    my $RMSs = [];
    my $Aligns = [];
    my $Fits = [];
    my $Eqs = [];
    my $Is = [];
    my $Ss = [];
    my $Ps = [];

    my $domain_keys = $model->models->keys;
    foreach my $domain (@$domain_keys) {
        my $l = $model->model($domain)->linker;

        $Scs->push($l->{'Sc'});
        $RMSs->push($l->{'RMS'});
        $Aligns->push($l->{'Align'});
        $Fits->push($l->{'Fit'});
        $Eqs->push($l->{'Eq'});
        $Is->push($l->{'I'});
        $Ss->push($l->{'S'});
        $Ps->push($l->{'P'});
    }

    $, = "\t";
    printf $pattern,
    basename($ENV{PWD}), $truthfile, $truth->size, 
    $modelfile, $model->size, scalar(@$iaction_keys), 
    100 * $model->size/$truth->size, 
    ($min_rmsd || 'nan'),
#     $crmsd,
    ($overlap || 'nan'),
    ($irmsds->mean || 'nan'),
    ($zscores->mean || 'nan'),
    ($pvals->mean || 'nan'),
    ($evals->mean || 'nan'), 
    ($seqids->mean || 'nan'),
    ($Scs->mean() || 'nan'),
    ($RMSs->mean || 'nan'),
    ($Aligns->mean || 'nan'),
    ($Fits->mean || 'nan'),
    ($Eqs->mean || 'nan'),
    ($Is->mean || 'nan'),
    ($Ss->mean || 'nan'),
    ($Ps->mean || 'nan'),
    ;
}

__END__


