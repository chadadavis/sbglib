#!/usr/bin/env perl

use warnings;

use EMBL::STAMP;
use Carp;
use Data::Dumper;

my $dom = shift;
unless ($dom) {
    carp "Please specify as file of stamp formatted domains.\n";
    return;
}

# Get config setttings
my $stamp = $config->val('stamp', 'executable') || 'stamp';
my $min_fit = $config->val('stamp', 'min_fit') || 30;
my $sc_cut = $config->val('stamp', 'sc_cut') || 2.0;
my $min_sc = $sc_cut;
my $stamp_pars = $config->val('stamp', 'params') || 
    '-n 2 -slide 5 -s -secscreen F -opd';
$stamp_pars .= " -scancut $sc_cut";

# Read input domains into %DOM hash
# stampid's into $dom_s space-separated
my $in = new EMBL::DomainIO(-file=>$dom);
my $out = new EMBL::DomainIO();
my $dom_s;
my %DOM;
while (my $dom = $in->next_domain) {
    $DOM{$dom->stampid} = $out->write($dom, -newline=>1);
    $dom_s .= $dom->stampid . ' ';
}

unless (keys(%DOM) > 1) {
    carp "Need at least two domains.\n";
    return;
}

# tempfiles
$tmp_prefix = "tmp_$$";
$tmp_probe = $tmp_prefix . ".probe";
$tmp_scan = $tmp_prefix . ".scan";
$tmp_doms = $tmp_prefix . ".db";

# Names of stampid's
@DSET = keys %DOM;

%TRIED = ();
%HAVE = ();

# Starting probe
$probe = $DSET[0];

# No. Domains that we haven't tried yet
$missing = @DSET;
# No. domains tried;
$probes_tried=0;

# ?
$in_disjoint=0;
$n_disjoins=0;


while(($missing>0) && ($probes_tried<@DSET)) {
    # Get another probe from the set that are included
    if($probe eq "") { 
        foreach $dom (keys %HAVE) {
            if(!defined($TRIED{$dom})) { $probe = $dom; }
        }
    }
    # Get another probe from anywhere (i.e. unconnected now)
    if($probe eq "") { 
        foreach $dom (@DSET) {
            if(!defined($TRIED{$dom})) { 
                $probe = $dom; 
                $in_disjoint=1;
                printf("%%Warning potential disjoint \n");
            }
        }
    }
    if($probe eq "") {
        printf("Out of probes and %d still missing\n",$missing);
    }
#  printf("STAMP_SET F %s P %s VS %d OF %d doms\n",$fold,$probe,$missing,$ndom);
    open(OUT,">$tmp_probe") || die "Error writing $tmp_probe\n";
    print OUT $DOM{$probe};
    close(OUT);
    open(OUT,">$tmp_doms") || die "Error writing $tmp_doms\n";
    foreach $dom (@DSET) {
        if((!defined($HAVE{$dom})) && ($dom ne $probe)) {
            print OUT $DOM{$dom};
            
        }
    }
    close(OUT);
    $com = $stamp . " " . $stamp_pars . " -l ".$tmp_probe." -prefix ".$tmp_prefix." -d ".$tmp_doms."|";
    open(IN,"$com") || die "Error running/reading $com\n";
    %KEEP = ();
    while(<IN>) {
        if((/^Scan/) && (!/skipped/) && (!/error/) && (!/missing/)) {
            chomp;
            print "%",$_;
            #Scan 1ddiA.c.25.1.4-1 1qfjB.c.25.1.1-1    1   5.772   1.816  153  135  162  102  102    9  19.61  82.35 7.27e-43
            @t = split(/\s+/);
            $id1 = $t[1];
            $id2 = $t[2];
            $sc = $t[4];
            $nfit = $t[9];
            if(($sc > 0.5) && (($sc>=$min_sc) || ($nfit >= $min_fit))) {
                $HAVE{$id1}=1;
                $HAVE{$id2}=1;
                $KEEP{$id1}=1;
                $KEEP{$id2}=1;
                print " ** ";
            }
            print "\n";
        }
    }
    close(IN);
    $com = "sorttrans -f ".$tmp_scan." -s Sc 0.5 -i |";
    open(IN,"$com") || die "Error running/reading $com\n";
    $output=0;
    $trans_s = "";
    $good_trans=0; # Only good if something other than the probe is there
    $nd=0;
    while(<IN>) {
        if((!/\%/) && (!/\#/)) {
            if(/\{/) {
#         printf("Changed %s\n",$_);
                if($nd>0) {
                    s/_[0-9]+ {/ {/
                }
                $nd++;
#         printf("     to %s\n",$_);
                $id = (split(/\s+/,$_))[1];
                if(defined($KEEP{$id})) { 
                    if($id ne $probe) { $good_trans=1 }
                    $output=1;
                } else { 
                    $output=0 
                }
            }
            if($output==1) { 
                $trans_s .= $_;
            }
        }
    }
    
    close(IN);
    if($good_trans==1) {
        print "%TRANS_BEGIN\n";

#         print STDERR "trans_s:\n$trans_s:\n";

        my $doms = string2doms($trans_s);
        my $tmpout = new EMBL::DomainIO(-fh=>\*STDOUT);
        for my $td (@$doms) {
#             print "td: ", Dumper($td), ":\n";
#             $tmpout->write($td,-newline=>1);
        }

#     print STDERR "doms:@$doms:\n";
        my @ordering = split(/\s+/, $dom_s);
#     print STDERR "ordering:@ordering:\n";
        my $ordered = reorder2(\@ordering, $doms, 'stampid');
#     print STDERR "ordered:@$ordered:\n";
        $trans_s_reordered = doms2string($ordered);
#     print STDERR "string:$trans_s_reordered:\n";

#         $trans_s_reordered = reorder($trans_s,$dom_s);



        print $trans_s_reordered;
        print "%TRANS_END\n";
        if($in_disjoint==1) {
            $n_disjoins++;
        }
    }
    
    $TRIED{$probe}=1;
    $probes_tried++;
    $probe = "";
    $missing = @DSET;
    foreach $dom (keys %HAVE) { $missing-- }
}


printf("%%Summary %4d out of %4d domains linked using %4d probes giving a total of %4d trans files (when linked)\n", 
       @DSET-$missing,scalar(@DSET),$probes_tried,$n_disjoins+1);

unlink $tmp_probe;
unlink $tmp_doms;
unlink $tmp_scan;


