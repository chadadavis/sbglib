#!/usr/bin/env perl

=head1 NAME

B<sbgeval> - Evaluate a complex against models of it

=head1 SYNOPSIS

 sbgeval true-complex-file.stor model1.stor model2.stor ...

=head1 DESCRIPTION


=head1 OPTIONS

=head2 -h Print this help page

=head1 SEE ALSO



=cut

################################################################################


use strict;
use warnings;
use feature 'say';
use Pod::Usage;
use Getopt::Long;
use Moose::Autobox;
use autobox ARRAY => 'SBG::List';
use File::Basename;

# TODO
# use SBG::Measure;
use SBG::List qw/mean/;

use SBG::Complex;
use SBG::Storable;

################################################################################


my %ops;
my $result = GetOptions(\%ops,
                        'h|help',
    );                  
if ($ops{'h'}) { pod2usage(-exitval=>1, -verbose=>2); }


################################################################################

my $truthfile = shift or pod2usage(-exitval=>1);
my $truth = retrieve $truthfile;

my $pattern = 
    "%4s %20s %3d %28s %3d %4d %6.2f %5.2f %6.2f %5.2f %7.3f %12g %12g %6.2f\n";
my $header  = sprintf 
    "#%3s %20s %3s %28s %3s %4s %6s %5s %6s %5s %7s %12s %12s %6s\n",
    qw/PDB Benchmark N Model N Iact Cover RMSD Olap iRMSD Z Pval Eval SeqID/;
print $header;

foreach my $modelfile (@ARGV) { 
    my $model = retrieve $modelfile;

    my $min_rmsd = $model->min_rmsd($truth) || 'nan';
    # This will only work on *very* similar complexes
#     my $crmsd = $model->complexrmsd($truth) || 'nan';

    # linear overlap of spheres (cofm+rg) (as % of maximum possible overlap)
    my $overlap = 100 * $model->overlap($truth);

    my $irmsds = [];
    my $zscores = [];
    my $pvals = [];
    my $evals = [];
    my $seqids = [];

    my $iaction_keys = $model->interactions->keys;
    foreach my $iaction_key (@$iaction_keys) {
#         say $iaction_key;
        my $interaction = $model->interaction($iaction_key);
        $irmsds->push($interaction->score('irmsd'));
        $zscores->push($interaction->score('zscore'));
        $pvals->push($interaction->score('pval'));

        my $template_keys = $interaction->templates->keys;
        foreach my $template_key (@$template_keys) {
            my $template = $interaction->template($template_key);
            # fam superf and fold relations marked by 'REL' in eval
            if ($template->score('eval') !~ /REL/) {
                $evals->push($template->score('eval'));
                $seqids->push($template->score('seqid'));
            }
        }
    }

    $, = "\t";
    printf $pattern,
#     print $pattern,
    basename($ENV{PWD}), $truthfile, $truth->size, 
    $modelfile, $model->size, scalar(@$iaction_keys), 
    100 * $model->size/$truth->size, 
    $min_rmsd,
#     $crmsd,
    $overlap,
    $irmsds->mean, 
    $zscores->mean, 
    $pvals->mean, 
    $evals->mean || 'nan', 
    $seqids->mean || 'nan',
    ;

}

__END__


